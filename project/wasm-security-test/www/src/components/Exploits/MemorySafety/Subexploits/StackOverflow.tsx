import React, { useState, useContext } from 'react';
import * as wasm from "wasm-security-test";
import WasmErrorDisplay from '../../../Utils/WasmErrorDisplay';
import { WasmErrorContext } from '../../../../App';
import CodeViewer from '../../../Utils/CodeViewer';
import StarryNightHighlighter from '../../../Utils/StarryNightHighlighter';
import { RunButton, OutputPanel, SecurityMessage } from '../../../Shared';

const StackOverflow: React.FC = () => {
  const [output, setOutput] = useState<string>('');
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const { clearErrors } = useContext(WasmErrorContext);

  const runStackOverflow = () => {
    clearErrors();
    setIsRunning(true);
    
    // Add a warning immediately to give feedback
    setOutput('<span style="color:#dc3545;font-weight:500">Attempting to trigger stack overflow... This might freeze or crash your browser tab!</span>');
    
    // Small delay to allow UI to update before potentially crashing
    setTimeout(() => {
      try {
        wasm.stack_overflow();
        setOutput('<span style="color:green">No error: Stack overflow did not occur (unexpected in WASM).</span>');
      } catch (e) {
        const error = e as Error;
        setOutput(`<span style="color:red">Error: ${error.message}</span>`);
      } finally {
        setIsRunning(false);
      }
    }, 100);
  };

  return (
    <>
      <div className="exploit-explanation">
        <h3>Stack Overflow in WebAssembly</h3>
        <p>
          <strong>Explanation:</strong> In WebAssembly, stack overflows are always detected and immediately 
          trap (abort) execution. Unlike native code, there is no way to overwrite return addresses or corrupt 
          stack memory. Rust code is always protected: any stack overflow will terminate the program, and there 
          is no way to recover or exploit it. This is a built-in security feature of the WASM runtime.
        </p>
        
        <div className="info-box">
          <strong>Note:</strong> While a WASM trap is supposed to throw a catchable error in JavaScript, 
          stack overflows are a special case. Because the browser and WASM share the same call stack, 
          a deep stack overflow may crash or freeze your browser tab, rather than just throwing an error. 
          This is a limitation of current browser engines, not a flaw in WASM or Rust.
        </div>
        
        <CodeViewer
          singleCode={`// Rust code in src/memory_safety.rs\n#[wasm_bindgen]\n#[allow(unconditional_recursion)]\npub fn stack_overflow() {\n    // Recursive call with no termination condition\n    stack_overflow(); // Will continue until stack memory is exhausted\n}`}
          title="Stack Overflow Implementation"
        />
      </div>
      
      <div className="exploit-controls">
        <SecurityMessage type="warning" title="Warning">
          Clicking the run button below will likely crash your browser tab due to infinite recursion and stack overflow!
        </SecurityMessage>
        
        <RunButton 
          type="unsafe"
          onClick={runStackOverflow}
          disabled={isRunning}
        >
          {isRunning ? 'Running...' : 'Run Stack Overflow'}
        </RunButton>
      </div>
      
      {output && (
        <OutputPanel title="Result" type="error">
          <div id="stack-overflow-output" dangerouslySetInnerHTML={{ __html: output }} />
        </OutputPanel>
      )}
      
      <WasmErrorDisplay title="WebAssembly Panic" className="wasm-errors" />
    </>
  );
};

export default StackOverflow;