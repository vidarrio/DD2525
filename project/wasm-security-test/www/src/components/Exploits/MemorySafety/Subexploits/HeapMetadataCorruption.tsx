import React, { useState, useContext, useEffect } from 'react';
import * as wasm from "wasm-security-test";
import WasmErrorDisplay from '../../../Utils/WasmErrorDisplay';
import { WasmErrorContext } from '../../../../App';
import CodeViewer from '../../../Utils/CodeViewer';
import StarryNightHighlighter from '../../../Utils/StarryNightHighlighter';
import { InputField, RunButton, OutputPanel, ResultDisplay, SecurityMessage } from '../../../Shared';

const HeapMetadataCorruption: React.FC = () => {
  const [userInput, setUserInput] = useState<string>("CCCCCCCCCCCCCCCCC");
  const [position, setPosition] = useState<number>(12);
  const [output, setOutput] = useState<string>('');
  const [outputType, setOutputType] = useState<'safe' | 'unsafe' | null>(null);
  const { clearErrors } = useContext(WasmErrorContext);
  
  // Visualization
  const [region1, setRegion1] = useState<string[]>(Array(16).fill('A'));
  const [region2, setRegion2] = useState<string[]>(Array(16).fill('B'));
  const [overflowCount, setOverflowCount] = useState<number>(0);
  const [result, setResult] = useState<{region1: string, region2: string} | null>(null);

  // Update visualization when input or position changes
  useEffect(() => {
    // Reset to initial state
    const newRegion1 = Array(16).fill('A');
    const newRegion2 = Array(16).fill('B');
    
    // Calculate overflow
    const overflow = Math.max(0, (position + userInput.length) - 16);
    setOverflowCount(overflow);
    
    // Update visualization to show input placement
    for (let i = 0; i < userInput.length; i++) {
      const index = position + i;
      
      if (index < 16) {
        // Writing to region1
        newRegion1[index] = userInput[i];
      } else if (index < 32) {
        // Overflow into region2
        newRegion2[index - 16] = userInput[i];
      }
    }
    
    setRegion1(newRegion1);
    setRegion2(newRegion2);
  }, [userInput, position]);

  const runExploit = () => {
    try {
      const rawResult = wasm.unsafe_heap_corruption(userInput, position);
      
      if (rawResult.startsWith('[Error]')) {
        setOutput(`<span style="color:red"><pre>${rawResult}</pre></span>`);
        setResult(null);
      } else {
        // Parse result to extract region contents
        const lines = rawResult.trim().split('\n');
        const region1Content = lines[0].replace('Region 1: ', '');
        const region2Content = lines[1].replace('Region 2: ', '');
        
        setResult({
          region1: region1Content,
          region2: region2Content
        });
        
        setOutput('');
      }
      setOutputType('unsafe');
    } catch (e) {
      const error = e as Error;
      setOutput(`<span style="color:red">Error: ${error.message}</span>`);
      setResult(null);
      setOutputType('unsafe');
    }
  };

  const runMitigation = () => {
    clearErrors();
    try {
      const rawResult = wasm.safe_heap_corruption(userInput, position);
      
      if (rawResult.startsWith('[Error]')) {
        setOutput(`<span style="color:red"><pre>${rawResult}</pre></span>`);
        setResult(null);
      } else {
        // Parse result to extract region contents
        const lines = rawResult.trim().split('\n');
        const region1Content = lines[0].replace('Region 1: ', '');
        const region2Content = lines[1].replace('Region 2: ', '');
        
        setResult({
          region1: region1Content,
          region2: region2Content
        });
        
        setOutput('');
      }
      setOutputType('safe');
    } catch (e) {
      const error = e as Error;
      setOutput(`<span style="color:red">Error: ${error.message}</span>`);
      setResult(null);
      setOutputType('safe');
    }
  };

  return (
    <>
      <div className="exploit-explanation">
        <h3>Heap Metadata Corruption</h3>
        <p>
          <strong>Explanation:</strong> Heap metadata corruption occurs when a buffer overflow on the heap 
          overwrites data structures used by the memory allocator, or adjacent heap data. In native code, 
          this can lead to powerful exploits. In Rust, safe code always checks bounds and will panic (trap) 
          if you go out of bounds, preventing memory corruption. However, if you use <code>unsafe</code> Rust 
          and bypass bounds checks, you can still demonstrate how writing past a heap buffer can corrupt 
          adjacent data, just like in C/C++. WebAssembly itself does not add extra protection against heap 
          overflows; it is Rust's safety that prevents them in safe code.
        </p>
        
        <CodeViewer 
          title="Heap Metadata Corruption Implementation"
          unsafeCode={`// UNSAFE VERSION: Heap metadata corruption vulnerability
#[wasm_bindgen]
pub fn unsafe_heap_corruption(input: &str, position: usize) -> String {
    if position + input.len() > 32 {
        return format!(
            "[Error]\nYou tried to write {} bytes at position {} (position + input length = {}).\nThis would exceed the total buffer size of 32 bytes.\n\nNo write was performed. Please enter a shorter input or a lower position so that the data fits within the 32-byte region.",
            input.len(), position, position + input.len()
        );
    }

    // Allocate a single buffer, treat as two regions
    let mut buffer = vec![b'A'; 16];
    buffer.extend(vec![b'B'; 16]); // buffer[0..16] = 'A', buffer[16..32] = 'B'
    let (region1, region2) = buffer.split_at_mut(16);

    unsafe {
        let ptr = region1.as_mut_ptr();
        for (i, byte) in input.bytes().enumerate() {
            *ptr.add(position + i) = byte;
        }
    }

    let result1 = String::from_utf8_lossy(region1);
    let result2 = String::from_utf8_lossy(region2);
    format!("\nRegion 1: {}\nRegion 2: {}", result1, result2)
}`}
          safeCode={`// SAFE VERSION: Memory-safe heap operations
#[wasm_bindgen]
pub fn safe_heap_corruption(input: &str, position: usize) -> String {
    if position + input.len() > 32 {
        return format!(
            "[Error]\nYou tried to write {} bytes at position {} (position + input length = {}).\nThis would exceed the total buffer size of 32 bytes.\n\nNo write was performed. Please enter a shorter input or a lower position so that the data fits within the 32-byte region.",
            input.len(), position, position + input.len()
        );
    }

    // Allocate a single buffer, treat as two regions
    let mut buffer = vec![b'A'; 16];
    buffer.extend(vec![b'B'; 16]); // buffer[0..16] = 'A', buffer[16..32] = 'B'
    let (region1, region2) = buffer.split_at_mut(16);

    for (i, byte) in input.bytes().enumerate() {
        // This will panic if position + i >= 16
        region1[position + i] = byte;
    }

    let result1 = String::from_utf8_lossy(region1);
    let result2 = String::from_utf8_lossy(region2);
    format!("\nRegion 1: {}\nRegion 2: {}", result1, result2)
}`}
        />
        
        <div className="memory-legend">
          <div className="legend-item">
            <div className="legend-color buffer1"></div>
            <span>Region 1 (16 bytes)</span>
          </div>
          <div className="legend-item">
            <div className="legend-color buffer2"></div>
            <span>Region 2 (16 bytes)</span>
          </div>
          {overflowCount > 0 && (
            <div className="legend-item">
              <div className="legend-color overwritten"></div>
              <span>Overwritten bytes: {overflowCount}</span>
            </div>
          )}
        </div>
        
        <div className="memory-visualization">
          <div className="memory-row">
            <div className="memory-address">0x00</div>
            <div className="memory-cells">
              {region1.map((value, i) => (
                <div 
                  key={`region1-${i}`} 
                  className={`memory-cell buffer1 ${i >= position && i < (position + userInput.length) ? 'overwritten' : ''}`}
                  title={`Position: ${i}`}
                >
                  {value}
                </div>
              ))}
            </div>
          </div>
          <div className="memory-row">
            <div className="memory-address">0x10</div>
            <div className="memory-cells">
              {region2.map((value, i) => (
                <div 
                  key={`region2-${i}`} 
                  className={`memory-cell buffer2 ${i < (position + userInput.length - 16) && position + userInput.length > 16 ? 'overwritten' : ''}`}
                  title={`Position: ${i + 16}`}
                >
                  {value}
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
      
      <div className="exploit-controls">
        <div className="control-group">
          <InputField
            label="Enter data to write to heap vector"
            value={userInput}
            onChange={setUserInput}
            htmlFor="heap-user-input"
          />
          
          <div className="position-slider">
            <label htmlFor="heap-position">Start position:</label>
            <input 
              type="range" 
              id="heap-position"
              min="0" 
              max="15" 
              value={position}
              onChange={(e) => setPosition(parseInt(e.target.value))}
            />
            <span className="value">{position}</span>
          </div>
        </div>
        
        <div className="control-row">
          <RunButton 
            type="unsafe"
            onClick={runExploit}
          >
            Run Unsafe Version
          </RunButton>
          
          <RunButton 
            type="safe"
            onClick={runMitigation}
          >
            Run Safe Version
          </RunButton>
        </div>
      </div>
      
      {(output || result) && (
        <OutputPanel 
          title={outputType === 'unsafe' ? 'Unsafe Result' : 'Safe Result'}
          type={outputType === 'unsafe' ? 'error' : 'success'}
        >
          <div className={`status ${outputType === 'unsafe' ? 'vulnerable' : 'safe'}`}>
            {outputType === 'unsafe' ? 'Vulnerable' : 'Protected'}
          </div>
          
          {output ? (
            <div dangerouslySetInnerHTML={{ __html: output }} />
          ) : result && (
            <div className="buffer-results">
              <div className="result-info">
                <div><strong>Input:</strong> "{userInput}"</div>
                <div><strong>Position:</strong> {position}</div>
              </div>
              
              <div className="buffer-display">
                <h5>Result:</h5>
                <div className="buffer-content">
                  <div className="buffer-label">Region 1:</div>
                  <div className="buffer-value">{result.region1}</div>
                </div>
                <div className="buffer-content">
                  <div className="buffer-label">Region 2:</div>
                  <div className="buffer-value">{result.region2}</div>
                </div>
              </div>
              
              <SecurityMessage 
                type={outputType === 'unsafe' ? 'warning' : 'info'}
                title={outputType === 'unsafe' ? 'Memory Corruption Detected' : 'Memory Safe Operation'}
              >
                {outputType === 'unsafe' ? (
                  <>
                    The input was copied starting at position {position} in a heap buffer.
                    This allowed writing {Math.max(0, (position + userInput.length) - 16)} bytes past the end of the first region, 
                    which may have corrupted the second region or heap metadata as shown above!
                  </>
                ) : (
                  <>
                    The safe implementation uses Rust's bounds checking. If you try to write out of bounds, 
                    Rust will panic and this will be reported as an error. No heap metadata or adjacent 
                    memory is corrupted.
                  </>
                )}
              </SecurityMessage>
            </div>
          )}
        </OutputPanel>
      )}
      
      <WasmErrorDisplay title="WebAssembly Error" className="wasm-errors" />
    </>
  );
};

export default HeapMetadataCorruption;