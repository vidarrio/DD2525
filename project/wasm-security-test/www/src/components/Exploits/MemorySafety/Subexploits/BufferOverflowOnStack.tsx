import React, { useState, useContext, useEffect } from 'react';
import * as wasm from "wasm-security-test";
import WasmErrorDisplay from '../../../Utils/WasmErrorDisplay';
import { WasmErrorContext } from '../../../../App';
import CodeViewer from '../../../Utils/CodeViewer';
import StarryNightHighlighter from '../../../Utils/StarryNightHighlighter';
import { InputField, RunButton, OutputPanel, SecurityMessage } from '../../../Shared';
import '../../../../styles/memory-safety/memory-visualizer.css';

const BufferOverflowOnStack: React.FC = () => {
  const [userInput, setUserInput] = useState<string>("CCCCCCCCCCCCCCCCC");
  const [position, setPosition] = useState<number>(12);
  const [output, setOutput] = useState<string>('');
  const [outputType, setOutputType] = useState<'safe' | 'unsafe' | null>(null);
  const { clearErrors } = useContext(WasmErrorContext);
  
  // Visualization
  const [buffer1, setBuffer1] = useState<string[]>(Array(16).fill('A'));
  const [buffer2, setBuffer2] = useState<string[]>(Array(16).fill('B'));
  const [overflowCount, setOverflowCount] = useState<number>(0);
  const [result, setResult] = useState<{buffer1: string, buffer2: string} | null>(null);

  // Update visualization when input or position changes
  useEffect(() => {
    // Reset to initial state
    const newBuffer1 = Array(16).fill('A');
    const newBuffer2 = Array(16).fill('B');
    
    // Calculate overflow
    const overflow = Math.max(0, (position + userInput.length) - 16);
    setOverflowCount(overflow);
    
    // Update visualization to show input placement
    for (let i = 0; i < userInput.length; i++) {
      const index = position + i;
      
      if (index < 16) {
        // Writing to buffer1
        newBuffer1[index] = userInput[i];
      } else if (index < 32) {
        // Overflow into buffer2
        newBuffer2[index - 16] = userInput[i];
      }
    }
    
    setBuffer1(newBuffer1);
    setBuffer2(newBuffer2);
  }, [userInput, position]);

  const runExploit = () => {
    try {
      const rawResult = wasm.unsafe_copy_user_data(userInput, position);
      
      if (rawResult.startsWith('[Error]')) {
        setOutput(`<span style="color:red"><pre>${rawResult}</pre></span>`);
        setResult(null);
      } else {
        // Parse result to extract buffer contents
        const lines = rawResult.trim().split('\n');
        const buffer1Content = lines[0].replace('Buffer 1: ', '');
        const buffer2Content = lines[1].replace('Buffer 2: ', '');
        
        setResult({
          buffer1: buffer1Content,
          buffer2: buffer2Content
        });
        
        setOutput('');
      }
      setOutputType('unsafe');
    } catch (e) {
      const error = e as Error;
      setOutput(`<span style="color:red">Error: ${error.message}</span>`);
      setResult(null);
      setOutputType('unsafe');
    }
  };

  const runMitigation = () => {
    clearErrors();
    try {
      const rawResult = wasm.safe_copy_user_data(userInput, position);
      
      if (rawResult.startsWith('[Error]')) {
        setOutput(`<span style="color:red"><pre>${rawResult}</pre></span>`);
        setResult(null);
      } else {
        // Parse result to extract buffer contents
        const lines = rawResult.trim().split('\n');
        const buffer1Content = lines[0].replace('Buffer 1: ', '');
        const buffer2Content = lines[1].replace('Buffer 2: ', '');
        
        setResult({
          buffer1: buffer1Content,
          buffer2: buffer2Content
        });
        
        setOutput('');
      }
      setOutputType('safe');
    } catch (e) {
      const error = e as Error;
      setOutput(`<span style="color:red">Error: ${error.message}</span>`);
      setResult(null);
      setOutputType('safe');
    }
  };

  return (
    <>
      <div className="exploit-explanation">
        <h3>Buffer Overflow on Unmanaged Stack</h3>
        <p>
          <strong>Explanation:</strong> In native code, writing past the end of a stack buffer 
          can corrupt adjacent stack data, potentially leading to code execution or security 
          vulnerabilities. In Rust, safe code always checks bounds and will panic (trap) if you 
          go out of bounds, preventing memory corruption. However, if you use <code>unsafe</code> Rust 
          and bypass bounds checks, you can still demonstrate how adjacent stack data can be corrupted, 
          just like in C/C++. WebAssembly itself does not add extra protection against buffer overflows; 
          it is Rust's safety that prevents them in safe code.
        </p>
        
        <CodeViewer 
          title="Buffer Overflow Implementation"
          unsafeCode={`// UNSAFE VERSION: Buffer overflow vulnerability
#[wasm_bindgen]
pub fn unsafe_copy_user_data(input: &str, position: usize) -> String {
    if position + input.len() > 32 {
        return format!(
            "[Error]\nYou tried to write {} bytes at position {} (position + input length = {}).\nThis would exceed the total buffer size of 32 bytes.\n\nNo write was performed. Please enter a shorter input or a lower position so that the data fits within the 32-byte region.",
            input.len(), position, position + input.len()
        );
    }

    // Create two adjacent arrays in memory
    let mut buffer1 = [b'A'; 16]; // First buffer filled with 'A's
    let buffer2 = [b'B'; 16]; // Second buffer filled with 'B's
    
    unsafe {
        // Get a raw pointer to our first buffer
        let buffer_ptr = buffer1.as_mut_ptr();
        
        // Perform unsafe memory writes without bounds checking
        for (i, byte) in input.bytes().enumerate() {
            *buffer_ptr.add(position + i) = byte;
        }
    }
    
    // Show both buffers to demonstrate the corruption
    let result1 = String::from_utf8_lossy(&buffer1).to_string();
    let result2 = String::from_utf8_lossy(&buffer2).to_string();
    
    format!("\nBuffer 1: {}\nBuffer 2: {}", result1, result2)
}`}
          safeCode={`// SAFE VERSION: Memory-safe copy
#[wasm_bindgen]
pub fn safe_copy_user_data(input: &str, position: usize) -> String {
    if position + input.len() > 32 {
        return format!(
            "[Error]\nYou tried to write {} bytes at position {} (position + input length = {}).\nThis would exceed the total buffer size of 32 bytes.\n\nNo write was performed. Please enter a shorter input or a lower position so that the data fits within the 32-byte region.",
            input.len(), position, position + input.len()
        );
    }

    // Create two adjacent arrays in memory (mirroring unsafe version)
    let mut buffer1 = [b'A'; 16]; // First buffer filled with 'A's
    let buffer2 = [b'B'; 16]; // Second buffer filled with 'B's
    
    // Safe copy - panics if out of bounds
    for (i, byte) in input.bytes().enumerate() {
        buffer1[position + i] = byte;
    }
    
    // Show both buffers to demonstrate NO corruption in buffer2
    let result1 = String::from_utf8_lossy(&buffer1).to_string();
    let result2 = String::from_utf8_lossy(&buffer2).to_string();
    
    format!("\nBuffer 1: {}\nBuffer 2: {}", result1, result2)
}`}
        />
        
        <div className="memory-legend">
          <div className="legend-item">
            <div className="legend-color buffer1"></div>
            <span>Buffer 1 (16 bytes)</span>
          </div>
          <div className="legend-item">
            <div className="legend-color buffer2"></div>
            <span>Buffer 2 (16 bytes)</span>
          </div>
          {overflowCount > 0 && (
            <div className="legend-item">
              <div className="legend-color overwritten"></div>
              <span>Overwritten bytes: {overflowCount}</span>
            </div>
          )}
        </div>
        
        <div className="memory-visualization">
          <div className="memory-row">
            <div className="memory-address">0x00</div>
            <div className="memory-cells">
              {buffer1.map((value, i) => (
                <div 
                  key={`buffer1-${i}`} 
                  className={`memory-cell buffer1 ${i >= position && i < (position + userInput.length) ? 'overwritten' : ''}`}
                  title={`Position: ${i}`}
                >
                  {value}
                </div>
              ))}
            </div>
          </div>
          <div className="memory-row">
            <div className="memory-address">0x10</div>
            <div className="memory-cells">
              {buffer2.map((value, i) => (
                <div 
                  key={`buffer2-${i}`} 
                  className={`memory-cell buffer2 ${i < (position + userInput.length - 16) && position + userInput.length > 16 ? 'overwritten' : ''}`}
                  title={`Position: ${i + 16}`}
                >
                  {value}
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
      
      <div className="exploit-controls">
        <div className="control-group">
          <InputField
            htmlFor="user-input"
            label="Enter data to write to buffer"
            value={userInput}
            onChange={(value) => setUserInput(value)}
          />
          
          <div className="position-slider">
            <label htmlFor="position">Start position:</label>
            <input 
              type="range" 
              id="position"
              min="0" 
              max="15" 
              value={position}
              onChange={(e) => setPosition(parseInt(e.target.value))}
            />
            <span className="value">{position}</span>
          </div>
        </div>
        
        <div className="control-row">
          <RunButton 
            onClick={runExploit} 
            type="unsafe"
          >
            Run Unsafe Version
          </RunButton>
          
          <RunButton 
            onClick={runMitigation} 
            type="safe"
          >
            Run Safe Version
          </RunButton>
        </div>
      </div>
      
      {(output || result) && (
        <OutputPanel 
          type={outputType === 'unsafe' ? 'warning' : 'success'}
          title={`${outputType === 'unsafe' ? 'Unsafe Result' : 'Safe Result'} - ${outputType === 'unsafe' ? 'Vulnerable' : 'Protected'}`}
        >
          {output ? (
            <div dangerouslySetInnerHTML={{ __html: output }} />
          ) : result && (
            <div className="buffer-results">
              <div className="result-info">
                <div><strong>Input:</strong> "{userInput}"</div>
                <div><strong>Position:</strong> {position}</div>
              </div>
              
              <div className="buffer-display">
                <h5>Result:</h5>
                <div className="buffer-content">
                  <div className="buffer-label">Buffer 1:</div>
                  <div className="buffer-value">{result.buffer1}</div>
                </div>
                <div className="buffer-content">
                  <div className="buffer-label">Buffer 2:</div>
                  <div className="buffer-value">{result.buffer2}</div>
                </div>
              </div>
              
              <SecurityMessage 
                type={outputType === 'unsafe' ? 'warning' : 'info'}
                title={outputType === 'unsafe' ? 'Buffer Overflow Detected' : 'Memory Safe Operation'}
              >
                {outputType === 'unsafe' ? (
                  <>
                    The input was copied starting at position {position} in the first 16-byte buffer.
                    This allowed writing {Math.max(0, (position + userInput.length) - 16)} bytes past the end of the first buffer, 
                    corrupting the second adjacent buffer as shown above!
                  </>
                ) : (
                  <>
                    The safe implementation prevented the buffer overflow by performing bounds checking 
                    and safely handling the input data.
                  </>
                )}
              </SecurityMessage>
            </div>
          )}
        </OutputPanel>
      )}
      
      <WasmErrorDisplay title="WebAssembly Error" className="wasm-errors" />
    </>
  );
};

export default BufferOverflowOnStack;