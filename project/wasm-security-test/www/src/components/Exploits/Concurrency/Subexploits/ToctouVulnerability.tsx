import React, { useState, useContext, useEffect } from 'react';
import * as wasm from "wasm-security-test";
import WasmErrorDisplay from '../../../Utils/WasmErrorDisplay';
import { WasmErrorContext } from '../../../../App';
import CodeViewer from '../../../Utils/CodeViewer';
import StarryNightHighlighter from '../../../Utils/StarryNightHighlighter';
import { 
  ImplementationContainer, 
  InputField, 
  RunButton, 
  ResultDisplay, 
  SecurityMessage 
} from '../../../Shared';
import '../../../../styles/concurrency/toctou-visualizer.css';

const ToctouVulnerability: React.FC = () => {
  const [filename, setFilename] = useState<string>("config.txt");
  const [userId, setUserId] = useState<string>("guest");
  const [output, setOutput] = useState<string>('');
  const [outputType, setOutputType] = useState<'vulnerable' | 'secure' | null>(null);
  const { clearErrors } = useContext(WasmErrorContext);
  
  // Race condition visualization state
  const [isRaceConditionActive, setIsRaceConditionActive] = useState<boolean>(false);
  const [timelineStep, setTimelineStep] = useState<number>(0);
  const [raceConditionResult, setRaceConditionResult] = useState<string>('');
  const [permissionCacheState, setPermissionCacheState] = useState<string>('');
  const [fileSystemState, setFileSystemState] = useState<string>('');
  const [isMitigationEnabled, setIsMitigationEnabled] = useState<boolean>(false);

  // Update system state when component loads
  useEffect(() => {
    updateSystemStates();
  }, []);

  const updateSystemStates = () => {
    try {
      const permState = wasm.get_permission_cache_state();
      const fsState = wasm.get_file_system_state();
      setPermissionCacheState(permState);
      setFileSystemState(fsState);
    } catch (error) {
      console.error('Error updating system states:', error);
    }
  };

  const clearCache = () => {
    try {
      const result = wasm.clear_permission_cache();
      setOutput(`<span style="color:green">${result}</span>`);
      updateSystemStates();
    } catch (error) {
      const err = error as Error;
      setOutput(`<span style="color:red">Error: ${err.message}</span>`);
    }
  };

  const runVulnerableAccess = () => {
    try {
      clearErrors();
      const result = wasm.vulnerable_file_access(filename, userId);
      setOutput(`<span style="color:orange">${result}</span>`);
      setOutputType('vulnerable');
      updateSystemStates();
    } catch (error) {
      const err = error as Error;
      setOutput(`<span style="color:red">Error: ${err.message}</span>`);
    }
  };

  const runSecureAccess = () => {
    try {
      clearErrors();
      const result = wasm.secure_file_access(filename, userId);
      setOutput(`<span style="color:green">${result}</span>`);
      setOutputType('secure');
      updateSystemStates();
    } catch (error) {
      const err = error as Error;
      setOutput(`<span style="color:red">Error: ${err.message}</span>`);
    }
  };

  const simulateRaceCondition = () => {
    if (!isMitigationEnabled) {
      // Demonstrate vulnerable race condition
      setIsRaceConditionActive(true);
      setTimelineStep(0);
      setRaceConditionResult('');
      
      const steps = [
        "Step 1: Checking permission for guest user...",
        "Step 2: Permission denied - access should be blocked",
        "Step 3: RACE CONDITION - Attacker modifies permissions during delay!",
        "Step 4: Using the file with modified permissions...",
        "Step 5: VULNERABILITY EXPLOITED - Unauthorized access granted!"
      ];

      let currentStep = 0;
      const stepInterval = setInterval(() => {
        setTimelineStep(currentStep);
        
        if (currentStep === 2) {
          // Attacker modifies permissions during the delay
          try {
            const raceResult = wasm.modify_permission_during_delay(userId, filename, true);
            setRaceConditionResult(raceResult);
          } catch (error) {
            console.error('Error in race condition simulation:', error);
          }
        }
        
        if (currentStep === 4) {
          // Final vulnerable access attempt
          try {
            const result = wasm.vulnerable_file_access(filename, userId);
            setOutput(`<span style="color:red">RACE CONDITION EXPLOITED: ${result}</span>`);
          } catch (error) {
            const err = error as Error;
            setOutput(`<span style="color:red">Error: ${err.message}</span>`);
          }
        }
        
        currentStep++;
        if (currentStep >= steps.length) {
          clearInterval(stepInterval);
          setIsRaceConditionActive(false);
          updateSystemStates();
        }
      }, 1000);
    } else {
      // Demonstrate secure implementation
      setIsRaceConditionActive(true);
      setTimelineStep(0);
      setRaceConditionResult('');
      
      const secureSteps = [
        "Step 1: Initiating secure atomic access...",
        "Step 2: Checking permission at time of use",
        "Step 3: MITIGATION ACTIVE - Atomic check-and-use operation",
        "Step 4: Permission denied - access blocked securely",
        "Step 5: SECURE - Race condition prevented!"
      ];

      let currentStep = 0;
      const stepInterval = setInterval(() => {
        setTimelineStep(currentStep);
        
        if (currentStep === 4) {
          // Secure access attempt
          try {
            const result = wasm.secure_file_access(filename, userId);
            setOutput(`<span style="color:green">SECURE ACCESS: ${result}</span>`);
          } catch (error) {
            const err = error as Error;
            setOutput(`<span style="color:red">Error: ${err.message}</span>`);
          }
        }
        
        currentStep++;
        if (currentStep >= secureSteps.length) {
          clearInterval(stepInterval);
          setIsRaceConditionActive(false);
          updateSystemStates();
        }
      }, 1000);
    }
  };

  const raceConditionSteps = isMitigationEnabled ? [
    {
      title: "Atomic Check & Use",
      description: "Secure atomic operation begins",
      time: "T+0ms"
    },
    {
      title: "Permission Validation",
      description: "Checking permission at time of use",
      time: "T+1ms"
    },
    {
      title: "Mitigation Active",
      description: "Atomic check-and-use operation prevents race",
      time: "T+2ms"
    },
    {
      title: "Access Decision",
      description: "Permission denied - access blocked securely",
      time: "T+3ms"
    },
    {
      title: "Secure Result",
      description: "Race condition prevented successfully",
      time: "T+4ms"
    }
  ] : [
    {
      title: "Permission Check",
      description: "Checking permission for guest user",
      time: "T+0ms"
    },
    {
      title: "Initial Denial",
      description: "Permission denied - access should be blocked",
      time: "T+10ms"
    },
    {
      title: "Race Window",
      description: "VULNERABILITY: Attacker modifies permissions during delay!",
      time: "T+50ms"
    },
    {
      title: "File Access",
      description: "Using the file with modified permissions",
      time: "T+100ms"
    },
    {
      title: "Exploit Success",
      description: "COMPROMISED: Unauthorized access granted!",
      time: "T+120ms"
    }
  ];

  return (
    <div className="toctou-container">
      <h3>Time-of-Check-to-Time-of-Use (TOCTOU) Race Condition</h3>
      
      <div className="exploit-description">
        <p>
        This demonstration shows a Time-of-Check-to-Time-of-Use (TOCTOU) race condition vulnerability.
        In this scenario, there's a critical time gap between checking user permissions and actually 
        accessing the file, creating an opportunity for attackers to modify the permission state.
        </p>
        <p>
          <strong>Attack Vector:</strong> An attacker can modify the permission cache during the delay 
          between the security check and file access, potentially gaining unauthorized access to sensitive files.
        </p>
        <p>
          <strong>Files available:</strong>
          <br />• <code>config.txt</code> - Contains admin configuration (admin only)
          <br />• <code>user_data.txt</code> - Contains user data (admin only) 
          <br />• <code>public.txt</code> - Public information (accessible to all)
        </p>

        <CodeViewer 
          title="TOCTOU Race Condition Implementation"
          unsafeCode={`// VULNERABLE: Separate check and use operations with delay
#[wasm_bindgen]
pub fn vulnerable_file_access(filename: &str, user_id: &str) -> String {
    // TIME OF CHECK: Validate permission
    let key = format!("{}:{}", user_id, filename);
    let has_permission = permission_cache()
        .lock()
        .unwrap()
        .get(&key)
        .copied()
        .unwrap_or_else(|| has_default_permission(filename, user_id));
    
    if !has_permission {
        return format!("ACCESS DENIED: User {} cannot access {}", user_id, filename);
    }
    
    // ⚠️ VULNERABILITY: Delay creates TOCTOU window
    for i in 0..1000 { let _ = i; }
    
    // TIME OF USE: Access file (vulnerability window!)
    match file_system().lock().unwrap().get(filename) {
        Some(content) => format!("SUCCESS: Read file '{}': {}", filename, content),
        None => format!("ERROR: File '{}' not found", filename)
    }
}

// EXPLOIT: Modify permissions during TOCTOU window
#[wasm_bindgen]
pub fn modify_permission_during_delay(user_id: &str, filename: &str, grant_access: bool) -> String {
    let key = format!("{}:{}", user_id, filename);
    permission_cache().lock().unwrap().insert(key.clone(), grant_access);
    format!("RACE CONDITION: Modified permission for '{}' to {}", key, grant_access)
}`}
          safeCode={`// SECURE: Atomic check-and-use operation
#[wasm_bindgen]
pub fn secure_file_access(filename: &str, user_id: &str) -> String {
    let files = file_system().lock().unwrap();
    
    // ✅ Check permission at the exact moment of use
    if !has_default_permission(filename, user_id) {
        return format!("ACCESS DENIED: User {} cannot access {}", user_id, filename);
    }
    
    // ✅ Immediately use the resource while we have the lock
    match files.get(filename) {
        Some(content) => format!("SECURE SUCCESS: Read file '{}': {}", filename, content),
        None => format!("ERROR: File '{}' not found", filename)
    }
}
`}
        />
        
        <div className="mitigation-toggle">
          <label className="toggle-switch">
            <input 
              type="checkbox" 
              checked={isMitigationEnabled}
              onChange={(e) => setIsMitigationEnabled(e.target.checked)}
            />
            <span className="toggle-slider"></span>
          </label>
          <span className="toggle-label">
            {isMitigationEnabled ? 'Secure Implementation' : 'Vulnerable Implementation'}
          </span>
        </div>
      </div>

      {/* Timeline Visualization - Always visible above buttons */}
      <div className="timeline-visualization">
        <h4>
          {isMitigationEnabled ? 'Secure Access Timeline' : 'Race Condition Timeline'}
        </h4>
        <div className="timeline">
          {raceConditionSteps.map((step, index) => (
            <div 
              key={index}
              className={`timeline-step ${index <= timelineStep ? 'active' : ''} ${
                index === 2 && !isMitigationEnabled ? 'vulnerability' : 
                index === 2 && isMitigationEnabled ? 'secure' : ''
              }`}
            >
              <div className="timeline-marker">
                <span className="step-number">{index + 1}</span>
              </div>
              <div className="timeline-content">
                <h6>{step.title}</h6>
                <p>{step.description}</p>
                <small>{step.time}</small>
              </div>
            </div>
          ))}
        </div>
        
        {raceConditionResult && (
          <div className={`race-result ${isMitigationEnabled ? 'secure-result' : 'vulnerable-result'}`}>
            <strong>Result:</strong> {raceConditionResult}
          </div>
        )}
      </div>

      <div className="exploit-implementations">
        <ImplementationContainer
          title="Vulnerable: TOCTOU Race Condition"
          description="Permission check and file access happen at different times, creating a race condition window."
          type="vulnerable"
        >
          <div className="input-controls">
            <div className="input-group">
              <label htmlFor="filename">Filename:</label>
              <select 
                id="filename"
                value={filename} 
                onChange={(e) => setFilename(e.target.value)}
              >
                <option value="config.txt">config.txt (admin only)</option>
                <option value="user_data.txt">user_data.txt (admin only)</option>
                <option value="public.txt">public.txt (public access)</option>
              </select>
            </div>
            
            <div className="input-group">
              <label htmlFor="userId">User ID:</label>
              <select 
                id="userId"
                value={userId} 
                onChange={(e) => setUserId(e.target.value)}
              >
                <option value="guest">guest (limited access)</option>
                <option value="admin">admin (full access)</option>
              </select>
            </div>
          </div>

          <div className="exploit-controls">
            {!isMitigationEnabled ? (
              <RunButton type="unsafe" onClick={runVulnerableAccess}>
                Test Vulnerable Access
              </RunButton>
            ) : (
              <RunButton type="safe" onClick={runSecureAccess}>
                Test Secure Access
              </RunButton>
            )}
            
            <RunButton 
              type={isMitigationEnabled ? 'safe' : 'unsafe'}
              onClick={simulateRaceCondition}
              disabled={isRaceConditionActive}
            >
              {isRaceConditionActive ? 'Simulating...' : 
               isMitigationEnabled ? 'Demo Secure Access' : 'Simulate Race Condition'}
            </RunButton>
            
            <RunButton type="primary" onClick={clearCache}>
              Clear Permission Cache
            </RunButton>
          </div>

          <SecurityMessage type="warning" title="Security Issue">
            The delay between permission check and file access 
            creates a window where attackers can modify the permission cache, leading to 
            unauthorized access to sensitive files.
          </SecurityMessage>
        </ImplementationContainer>

        <ImplementationContainer
          title="Secure: Atomic Check-and-Use"
          description="Permission check and file access happen atomically, preventing race conditions."
          type="secure"
        >
          <SecurityMessage type="success" title="Security Fix">
            Use atomic operations where permission checks and 
            resource access happen in a single, uninterruptible operation. This prevents 
            attackers from modifying state between check and use.
          </SecurityMessage>
        </ImplementationContainer>
      </div>

      {output && (
        <div className="results-panel">
          <h4>Execution Results</h4>
          <div className={`result-item active`}>
            <strong>Access Result:</strong>
            <div 
              className={`result-content ${outputType === 'secure' ? 'safe' : 'danger'}`}
              dangerouslySetInnerHTML={{ __html: output }}
            />
          </div>
        </div>
      )}

      {/* System State Display */}
      <div className="system-state">
        <div className="state-panel">
          <h5>File System State</h5>
          <pre className="state-content">{fileSystemState}</pre>
        </div>
        
        <div className="state-panel">
          <h5>Permission Cache State</h5>
          <pre className="state-content">{permissionCacheState}</pre>
        </div>
      </div>

      <WasmErrorDisplay />
    </div>
  );
};

export default ToctouVulnerability;