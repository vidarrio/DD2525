import React, { useState, useContext } from 'react';
import ToctouVulnerability from './Subexploits/ToctouVulnerability';
import { WasmErrorContext } from '../../../App';
import '../../../styles/concurrency/index.css';

const Concurrency: React.FC = () => {
  const [activeTab, setActiveTab] = useState<string>('toctou vulnerability');
  const { clearErrors } = useContext(WasmErrorContext);

  const changeTab = (tab: string) => {
    setActiveTab(tab);
    clearErrors(); // Clear errors when changing tabs
  };

  return (
    <div id="concurrency" className="page active">
      <h2>Concurrency Vulnerabilities</h2>
      <p className="section-intro">
        Concurrency vulnerabilities arise when multiple threads or processes access shared resources
        simultaneously without proper synchronization. These race conditions can lead to data corruption,
        privilege escalation, and other security issues. While WebAssembly runs in a single-threaded
        environment by default, these vulnerabilities can still manifest through asynchronous operations
        and shared memory access patterns.
      </p>
      
      <div className="tabs">
        <button 
          className={`tab-btn ${activeTab === 'toctou vulnerability' ? 'active' : ''}`}
          onClick={() => changeTab('toctou vulnerability')}
        >
          TOCTOU Vulnerability
        </button>
      </div>
      
      <div className="concurrency-content">
        {activeTab === 'toctou vulnerability' && <ToctouVulnerability />}
      </div>
    </div>
  );
};

export default Concurrency;
