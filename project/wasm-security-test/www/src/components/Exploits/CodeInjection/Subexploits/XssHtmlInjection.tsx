import React, { useState, useContext, useRef } from 'react';
import * as wasm from "wasm-security-test";
import WasmErrorDisplay from '../../../Utils/WasmErrorDisplay';
import { WasmErrorContext } from '../../../../App';
import CodeViewer from '../../../Utils/CodeViewer';
import { RunButton, SecurityMessage } from '../../../Shared';
import '../../../../styles/code-injection/xss-fix.css';

const XssHtmlInjection: React.FC = () => {
  const [userInput, setUserInput] = useState<string>('<img src="x" onerror="alert(\'XSS Attack!\')">');
  const [output, setOutput] = useState<string>('');
  const [outputType, setOutputType] = useState<'safe' | 'unsafe' | null>(null);
  const [showPayloads, setShowPayloads] = useState<boolean>(false);
  const [executedUnsafe, setExecutedUnsafe] = useState<boolean>(false);
  const [executedSafe, setExecutedSafe] = useState<boolean>(false);
  const unsafeContentRef = useRef<HTMLDivElement>(null);
  const safeContentRef = useRef<HTMLDivElement>(null);
  const { clearErrors } = useContext(WasmErrorContext);

  const runVulnerableVersion = () => {
    try {
      clearErrors();
      
      const result = wasm.vulnerable_render_user_content(userInput);
      setOutput(result);
      setOutputType('unsafe');
      setExecutedUnsafe(true); // Always set this so the demo area shows up
      
      // Show confirmation dialog after setting state
      const shouldExecute = window.confirm(`‚ö†Ô∏è DEMO: About to execute potentially malicious HTML content: ${userInput}\n\nThis is for educational purposes. Continue?`);
      
      // Use setTimeout to ensure the DOM has updated and the ref is available
      setTimeout(() => {
        if (unsafeContentRef.current) {
          if (shouldExecute) {
            // Extract HTML from the WASM result (remove "Generated HTML: " prefix)
            const htmlContent = result.replace("Generated HTML: ", "");
            
            // DANGER: Actually execute the HTML content for demonstration
            // Set the HTML content
            unsafeContentRef.current.innerHTML = htmlContent;
            
            // Extract and execute any script tags manually (since innerHTML doesn't execute them)
            const scriptRegex = /<script[^>]*>([\s\S]*?)<\/script>/gi;
            let match;
            while ((match = scriptRegex.exec(htmlContent)) !== null) {
              try {
                // Execute the script content
                const scriptContent = match[1];
                const func = new Function(scriptContent);
                func();
              } catch (scriptError) {
                console.error("Error executing script:", scriptError);
              }
            }
            
            // Handle event-based XSS (like onload, onerror, etc.)
            setTimeout(() => {
              const elements = unsafeContentRef.current?.querySelectorAll('*');
              elements?.forEach(element => {
                // Trigger any event handlers that might have been set
                if (element instanceof HTMLElement) {
                  // Trigger common XSS event handlers
                  try {
                    // Focus events (for input, textarea, etc. with autofocus)
                    if (element.hasAttribute('autofocus') || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                      element.focus();
                    }
                    
                    // Load events for various elements
                    if (element.onload) element.onload(new Event('load') as any);
                    if (element.onloadstart) element.onloadstart(new Event('loadstart') as any);
                    
                    // Error events (for img, video, audio, etc.)
                    if (element.onerror) element.onerror(new Event('error') as any);
                    
                    // Toggle events (for details elements)
                    if (element.tagName === 'DETAILS' && element.hasAttribute('open')) {
                      const toggleEvent = new Event('toggle');
                      element.dispatchEvent(toggleEvent);
                    }
                    
                    // Start events (for marquee)
                    if (element.tagName === 'MARQUEE') {
                      const startEvent = new Event('start');
                      element.dispatchEvent(startEvent);
                    }
                    
                    // Click events
                    if (element.onclick) element.onclick(new MouseEvent('click'));
                    
                    // Mouse events for hover effects
                    if (element.onmouseover) {
                      const mouseEvent = new MouseEvent('mouseover', { bubbles: true });
                      element.dispatchEvent(mouseEvent);
                    }
                    
                    // Form events
                    if (element.tagName === 'FORM') {
                      const buttons = element.querySelectorAll('button, input[type="submit"]');
                      buttons.forEach(button => {
                        if (button instanceof HTMLElement && button.onclick) {
                          button.click();
                        }
                      });
                    }
                  } catch (eventError) {
                    console.error("Error triggering event:", eventError);
                  }
                }
              });
            }, 100);
          } else {
            // User cancelled - show a message
            unsafeContentRef.current.innerHTML = '<p style="color: #666; font-style: italic;">Code execution cancelled by user</p>';
          }
        }
      }, 100);
    } catch (error) {
      console.error("Error running vulnerable version:", error);
    }
  };

  const runSecureVersion = () => {
    try {
      clearErrors();
      const result = wasm.secure_render_user_content(userInput);
      setOutput(result);
      setOutputType('safe');
      setExecutedSafe(true);
      
      // Try to execute the "safe" content to demonstrate sanitization works
      const shouldExecute = window.confirm(`üõ°Ô∏è SAFE DEMO: About to attempt execution of sanitized content: ${userInput}\n\nThis should be safe - the content will be sanitized. Continue?`);
      
      if (shouldExecute) {
        // Use setTimeout to ensure the DOM has updated and the ref is available
        setTimeout(() => {
          if (safeContentRef.current) {
            // Extract HTML from the WASM result (remove "Generated safe HTML: " prefix)
            const htmlContent = result.replace("Generated safe HTML: ", "");
            
            // Insert the sanitized HTML - this should be safe
            safeContentRef.current.innerHTML = htmlContent;
            
            // Try to extract and execute any script tags (there shouldn't be any functional ones)
            const scriptRegex = /<script[^>]*>([\s\S]*?)<\/script>/gi;
            let match;
            let scriptsFound = 0;
            while ((match = scriptRegex.exec(htmlContent)) !== null) {
              scriptsFound++;
              try {
                // This should not execute anything dangerous due to sanitization
                const scriptContent = match[1];
                const func = new Function(scriptContent);
                func();
              } catch (scriptError) {
                console.log("Script execution blocked or failed (this is expected for safe version):", scriptError);
              }
            }
            
            // Try to trigger events (should be safe due to sanitization)
            setTimeout(() => {
              const elements = safeContentRef.current?.querySelectorAll('*');
              let eventsTriggered = 0;
              elements?.forEach(element => {
                if (element instanceof HTMLElement) {
                  try {
                    if (element.hasAttribute('autofocus') || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                      element.focus();
                      eventsTriggered++;
                    }
                    if (element.onload) { element.onload(new Event('load') as any); eventsTriggered++; }
                    if (element.onloadstart) { element.onloadstart(new Event('loadstart') as any); eventsTriggered++; }
                    if (element.onerror) { element.onerror(new Event('error') as any); eventsTriggered++; }
                    if (element.tagName === 'DETAILS' && element.hasAttribute('open')) {
                      element.dispatchEvent(new Event('toggle'));
                      eventsTriggered++;
                    }
                    if (element.onmouseover) {
                      element.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
                      eventsTriggered++;
                    }
                  } catch (eventError) {
                    console.log("Event triggering blocked or failed (this is expected for safe version):", eventError);
                  }
                }
              });
              
              // Add a note about what was attempted
              if (safeContentRef.current && (scriptsFound > 0 || eventsTriggered > 0)) {
                const note = document.createElement('div');
                note.style.cssText = 'margin-top: 10px; padding: 8px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 4px; font-size: 12px; color: #2e7d32;';
                note.innerHTML = `<strong>Security Note:</strong> Attempted to execute ${scriptsFound} scripts and trigger ${eventsTriggered} events, but content was safely sanitized.`;
                safeContentRef.current.appendChild(note);
              }
            }, 100);
          }
        }, 100);
      } else {
        // User cancelled
        setTimeout(() => {
          if (safeContentRef.current) {
            safeContentRef.current.innerHTML = '<p style="color: #666; font-style: italic;">Safe execution cancelled by user</p>';
          }
        }, 100);
      }
    } catch (error) {
      console.error("Error running secure version:", error);
    }
  };

  const loadPayloadExample = (payload: string) => {
    setUserInput(payload);
    setOutput('');
    setOutputType(null);
    setExecutedUnsafe(false);
    // Clear the unsafe content div
    if (unsafeContentRef.current) {
      unsafeContentRef.current.innerHTML = '';
    }
  };

  const getXssPayloads = () => {
    try {
      const payloads = wasm.get_xss_payloads();
      return payloads.split('\n').slice(1); // Remove the header line
    } catch (error) {
      console.error("Error getting XSS payloads:", error);
      return [];
    }
  };

  return (
    <div className="exploit-container">
      <h3>HTML Content Generation from WASM</h3>
      
      <div className="exploit-description">
        <p>
          <strong>Explanation:</strong> WASM modules often process user data and generate HTML for display in web applications. 
          This occurs when WASM handles data processing, formatting, or rendering tasks that ultimately produce HTML content 
          for the DOM. The vulnerability arises at the WASM-to-JavaScript boundary where processed data becomes 
          part of HTML generation without proper sanitization.
        </p>
        <p>
          <strong>Scenario:</strong> A web application uses WASM to process user comments and package 
          them into the correct HTML structure for display. The WASM module takes raw user comment text 
          and wraps it in proper HTML elements with metadata (like submission info) before sending it 
          back to the frontend for DOM insertion. However, the application treats user input as trusted 
          content and directly embeds it into the HTML structure without validation.
        </p>
        <div className="wasm-connection">
          <h4>üîó WASM-to-DOM Data Flow</h4>
          <p>
            <strong>The Security Boundary:</strong> User input ‚Üí WASM processing ‚Üí HTML generation ‚Üí DOM insertion. 
            Vulnerabilities occur when WASM modules return HTML-formatted strings containing unsanitized user data, 
            which are then inserted into the DOM using <code>innerHTML</code> or similar methods.
          </p>
        </div>

        <CodeViewer 
          title="XSS HTML Injection Implementation"
          unsafeCode={`// VULNERABLE: Direct HTML generation with user input
// Rust (WASM side):
#[wasm_bindgen]
pub fn vulnerable_render_user_content(user_input: &str) -> String {
    // VULNERABILITY: Direct HTML generation with user input
    let html = format!(
        r#"<div class="user-content">
            <h3>User Content:</h3>
            <p>{}</p>
            <div class="metadata">Submitted by user</div>
        </div>"#, 
        user_input  // No sanitization!
    );
    
    format!("Generated HTML: {}", html)
}

// TypeScript (Frontend side):
import * as wasm from "wasm-security-test";

const runVulnerableVersion = () => {
    const userInput = '<script>alert("XSS!")</script>';
    const htmlContent = wasm.vulnerable_render_user_content(userInput);
    
    // DANGER: Direct DOM insertion of WASM-generated HTML
    document.getElementById('content').innerHTML = htmlContent;
    // ‚Üë This executes the XSS payload!
};`}
          safeCode={`// SECURE: Proper input sanitization
// Rust (WASM side):
#[wasm_bindgen]
pub fn secure_render_user_content(user_input: &str) -> String {
    // Sanitize the user input before using it
    let sanitized_input = sanitize_input(user_input);
    
    // Generate safe HTML with sanitized content
    let html = format!(
        r#"<div class="user-content-safe">
            <h3>Secure User Content:</h3>
            <p>{}</p>
            <div class="metadata">Safely rendered content</div>
        </div>"#, 
        sanitized_input  // Properly sanitized!
    );
    
    format!("Generated safe HTML: {}", html)
}

// Helper function to sanitize user input
fn sanitize_input(input: &str) -> String {
    input
        .replace("&", "&amp;")  // Must be first to avoid double-encoding
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
        .replace("'", "&#x27;")
        .replace("/", "&#x2F;")
        .chars()
        .filter(|c| c.is_ascii_graphic() || c.is_ascii_whitespace())
        .collect()
}

// TypeScript (Frontend side):
import * as wasm from "wasm-security-test";

const runSecureVersion = () => {
    const userInput = '<script>alert("XSS!")</script>';
    const safeHtmlContent = wasm.secure_render_user_content(userInput);
    
    // SAFE: WASM has already sanitized the content
    document.getElementById('content').innerHTML = safeHtmlContent;
    // ‚Üë Script tags are escaped as &lt;script&gt;
};`}
        />
      </div>

      <div className="exploit-implementations">
        <div className="realistic-interface">
          <div className="app-mockup">
            <div className="app-header">
              <h3>Comment System Demo</h3>
            </div>
            
            <div className="content-area">
              <div className="comment-form-section">
                <div className="form-header">
                  <h4>Add Comment</h4>
                </div>
                
                <div className="comment-form">
                  <div className="form-group">
                    <label>Comment Content</label>
                    <textarea
                      value={userInput}
                      onChange={(e) => setUserInput(e.target.value)}
                      placeholder="Enter your comment here..."
                      rows={4}
                      className="comment-textarea"
                    />
                  </div>
                  
                  <div className="form-actions">
                    <div className="action-group vulnerable">
                      <RunButton 
                        type="unsafe"
                        onClick={runVulnerableVersion}
                        className="btn btn-primary vulnerable"
                      >
                        üöÄ Publish Comment (Vulnerable)
                      </RunButton>
                    </div>
                    
                    <div className="action-group secure">
                      <RunButton 
                        type="safe"
                        onClick={runSecureVersion}
                        className="btn btn-primary secure"
                      >
                        üõ°Ô∏è Publish Comment (Secure)
                      </RunButton>
                    </div>
                  </div>
                </div>
              </div>

              {output && (
                <div className="comment-preview-section">
                  <div className="preview-header">
                    <h4>Generated Output</h4>
                  </div>
                  
                  <div className={`generated-output ${outputType}`}>
                    <div className="output-content">
                      {output}
                    </div>
                  </div>
                  
                  {/* Live execution demonstration for unsafe version */}
                  {outputType === 'unsafe' && executedUnsafe && (
                    <div className="live-execution-demo">
                      <div className="demo-header">
                        <h5>üö® Live Code Execution Demo</h5>
                        <p>The content below is actually executing the injected code:</p>
                      </div>
                      <div 
                        ref={unsafeContentRef} 
                        className="unsafe-content-execution"
                        style={{
                          border: '2px solid #dc3545',
                          padding: '15px',
                          borderRadius: '6px',
                          minHeight: '50px'
                        }}
                      />
                    </div>
                  )}
                  
                  {outputType === 'unsafe' && (
                    <SecurityMessage type="warning" title="Code Injection Executed">
                      The vulnerable WASM processor generated HTML containing unsanitized user input, 
                      which was then executed in the browser. In a real application, this would allow 
                      attackers to run arbitrary JavaScript with full access to the user's session.
                      {executedUnsafe && (
                        <p className="execution-note">
                          <strong>‚ö° Live Demo:</strong> The injected code was actually executed above!
                        </p>
                      )}
                    </SecurityMessage>
                  )}
                  
                  {outputType === 'safe' && (
                    <SecurityMessage type="success" title="Secure Processing Confirmed">
                      The updated WASM processor properly sanitized the input. HTML special characters 
                      are escaped, preventing XSS attacks while preserving the content for display.
                    </SecurityMessage>
                  )}
                </div>
              )}

              {showPayloads && (
                <div className="payload-testing-section">
                  <div className="section-header">
                    <h4>üî¨ Penetration Testing Payloads</h4>
                    <p>Common XSS vectors for testing comment systems</p>
                    <div className="payload-note">
                      <strong>Note:</strong> These payloads demonstrate different XSS techniques. Event-based payloads (img onerror, svg onload, etc.) 
                      are more likely to execute in innerHTML contexts than script tags.
                    </div>
                  </div>
                  <div className="payload-grid">
                    {getXssPayloads().map((payload: string, index: number) => (
                      <div
                        key={index}
                        className="payload-card"
                        onClick={() => loadPayloadExample(payload)}
                      >
                        <div className="payload-code">{payload}</div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <div className="testing-tools">
                <RunButton 
                  type="secondary"
                  onClick={() => setShowPayloads(!showPayloads)}
                  className="btn btn-secondary"
                >
                  {showPayloads ? 'üîí Hide' : 'üî¨ Show'} Testing Payloads
                </RunButton>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <WasmErrorDisplay />
    </div>
  );
};

export default XssHtmlInjection;
