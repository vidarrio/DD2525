import React, { useState, useContext } from 'react';
import XssHtmlInjection from './Subexploits/XssHtmlInjection';
import JavascriptCodeInjection from './Subexploits/JavascriptCodeInjection';
import { WasmErrorContext } from '../../../App';
import '../../../styles/code-injection/index.css';

const CodeInjection: React.FC = () => {
  const [activeTab, setActiveTab] = useState<string>('wasm dom boundary');
  const { clearErrors } = useContext(WasmErrorContext);

  const changeTab = (tab: string) => {
    setActiveTab(tab);
    clearErrors(); // Clear errors when changing tabs
  };

  return (
    <div id="code-injection" className="page active">
      <h2>WASM-JavaScript Interop Vulnerabilities</h2>
      <p className="section-intro">
        WebAssembly modules frequently need to interact with the JavaScript environment and DOM for UI updates, 
        API calls, and dynamic content generation. These <strong>WASM-to-JavaScript boundary crossings</strong> can introduce 
        security vulnerabilities when user input flows through WASM processing and back to the web platform 
        without proper validation at the interop layer.
      </p>

      <div className="code-injection-tabs">
        <button 
          className={`tab-btn ${activeTab === 'wasm dom boundary' ? 'active' : ''}`}
          onClick={() => changeTab('wasm dom boundary')}
        >
          WASM-to-DOM Injection
        </button>
        <button 
          className={`tab-btn ${activeTab === 'javascript code injection' ? 'active' : ''}`}
          onClick={() => changeTab('javascript code injection')}
        >
          Dynamic JS Generation
        </button>
      </div>

      <div className="code-injection-content">
        {activeTab === 'wasm dom boundary' && <XssHtmlInjection />}
        {activeTab === 'javascript code injection' && <JavascriptCodeInjection />}
      </div>
    </div>
  );
};

export default CodeInjection;