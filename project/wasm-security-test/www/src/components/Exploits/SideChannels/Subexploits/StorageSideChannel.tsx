import React, { useState, useContext, useRef, useEffect } from 'react';
import { WasmErrorContext } from '../../../../App';
import * as wasm from 'wasm-security-test';
import CodeViewer from '../../../Utils/CodeViewer';
import { 
  ImplementationContainer, 
  InputField, 
  RunButton, 
  ResultDisplay, 
  SecurityMessage, 
  AttackLog, 
  ExploitControls 
} from '../../../Shared';

const StorageSideChannel: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [unsafeResult, setUnsafeResult] = useState('');
  const [safeResult, setSafeResult] = useState('');
  const [isAttacking, setIsAttacking] = useState(false);
  const [hasRunAttack, setHasRunAttack] = useState(false);
  const [attackMode, setAttackMode] = useState<'unsafe' | 'safe'>('unsafe');
  const [attackLog, setAttackLog] = useState<string[]>([]);
  const [foundUsernames, setFoundUsernames] = useState<string[]>([]);
  const { addError } = useContext(WasmErrorContext);

  const abortControllerRef = useRef<AbortController | null>(null);
  const logContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Auto-scroll the log container when content changes
  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [attackLog]);

  const handleUnsafeSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const result = wasm.unsafe_check_credentials_storage(username, password);
      setUnsafeResult(result);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const handleSafeSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const result = wasm.safe_check_credentials_storage(username, password);
      setSafeResult(result);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const checkUsernameSafety = (username: string, mode: 'unsafe' | 'safe'): { exists: boolean, message: string } => {
    try {
      // Use a random password to trigger the error condition
      const password = "incorrect-password-" + Math.random().toString();
      
      const result = mode === 'unsafe' 
        ? wasm.unsafe_check_credentials_storage(username, password)
        : wasm.safe_check_credentials_storage(username, password);
      
      // Check if the error message reveals username existence
      const usernameExists = mode === 'unsafe' && !result.includes("Username does not exist");
      
      return {
        exists: usernameExists,
        message: result,
      };
    } catch (error) {
      console.error("Error checking username:", error);
      return { exists: false, message: `Error: ${error}` };
    }
  };

  const runUserEnumerationAttack = async (mode: 'unsafe' | 'safe') => {
    if (isAttacking) {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setIsAttacking(false);
      return;
    }

    setIsAttacking(true);
    setHasRunAttack(true);
    setAttackMode(mode);
    setAttackLog([`Starting username enumeration attack (${mode} implementation)...`]);
    setFoundUsernames([]);
    
    const controller = new AbortController();
    abortControllerRef.current = controller;
    const signal = controller.signal;

    try {
      // Common usernames to test
      const usernames = [
        "admin", "user", "guest", "moderator", 
        "root", "webmaster", "test", "support",
        "manager", "administrator"
      ];
      const newLog: string[] = [];
      const discovered: string[] = [];
      
      newLog.push(`Testing ${usernames.length} potential usernames...`);
      setAttackLog(newLog);
      
      for (let i = 0; i < usernames.length; i++) {
        if (signal.aborted) break;
        
        const username = usernames[i];
        const result = checkUsernameSafety(username, mode);
        
        if (result.exists) {
          newLog.push(`‚úÖ Found valid username: ${username} (Error message: "${result.message}")`);
          discovered.push(username);
        } else {
          newLog.push(`‚ùå Invalid username: ${username} (Error message: "${result.message}")`);
        }
        
        setAttackLog([...newLog]);
        setFoundUsernames([...discovered]);
        
        // Small delay to keep UI responsive
        await new Promise(r => setTimeout(r, 100));
      }
      
      if (discovered.length > 0) {
        newLog.push(`\nüîç Attack completed! Found ${discovered.length} valid usernames: ${discovered.join(', ')}`);
      } else {
        if (mode === 'unsafe') {
          newLog.push("\n‚ö†Ô∏è Attack completed but no usernames were found. This is unexpected for the vulnerable implementation.");
        } else {
          newLog.push("\n‚úÖ Attack failed! The secure implementation successfully protected against username enumeration.");
        }
      }
      
      setAttackLog([...newLog]);
      
    } catch (error) {
      if (!signal.aborted) {
        setAttackLog([...attackLog, `Error during attack: ${error}`]);
      }
    } finally {
      if (!signal.aborted) {
        setIsAttacking(false);
        abortControllerRef.current = null;
      }
    }
  };

  // Determine if we should display the attack results section
  const showAttackResults = isAttacking || hasRunAttack;

  return (
    <div className={`exploit-container ${hasRunAttack ? 'attack-complete' : ''}`}>
      <h3>Storage Side-Channel Attack</h3>
      
      <div className="exploit-description">
        <p>
          This demonstration shows how error messages can inadvertently leak information.
          The vulnerable version reveals whether a username exists in the system, even when 
          the login attempt fails. This allows attackers to enumerate valid usernames.
        </p>
        <p>
          <strong>Valid usernames:</strong> admin, user, guest, moderator
          <br />
          <strong>Passwords:</strong> [username]123 (e.g., admin123, user123)
        </p>
        
        <CodeViewer 
          title="Storage Side-Channel Implementation"
          unsafeCode={`// UNSAFE VERSION: Reveals whether username exists through different error messages
#[wasm_bindgen]
pub fn unsafe_check_credentials_storage(username: &str, password: &str) -> String {
    let stored_users = vec!["admin", "user", "guest", "moderator"];
    
    // This implementation leaks information about whether a username exists
    if !stored_users.contains(&username) {
        return "Error: Username does not exist".to_string();
    }
    
    // For the demo, we'll use simple fixed passwords
    let correct_password = match username {
        "admin" => "admin123",
        "user" => "user123",
        "guest" => "guest123",
        "moderator" => "mod123",
        _ => "",
    };
    
    if password != correct_password {
        return "Error: Incorrect password".to_string();
    }
    
    "Login successful".to_string()
}`}
          safeCode={`// SAFE VERSION: Does not reveal whether username exists
#[wasm_bindgen]
pub fn safe_check_credentials_storage(username: &str, password: &str) -> String {
    let stored_users = vec!["admin", "user", "guest", "moderator"];
    
    // This implementation uses a generic error message
    // that doesn't leak information about whether a username exists
    if !stored_users.contains(&username) {
        return "Error: Invalid username or password".to_string();
    }
    
    // Same password logic as unsafe version
    let correct_password = match username {
        "admin" => "admin123",
        "user" => "user123",
        "guest" => "guest123",
        "moderator" => "mod123",
        _ => "",
    };
    
    if password != correct_password {
        return "Error: Invalid username or password".to_string();
    }
    
    "Login successful".to_string()
}`}
        />
      </div>
      
      <div className="exploit-implementations">
        {/* Vulnerable Implementation */}
        <ImplementationContainer
          title="Vulnerable Implementation"
          description="This implementation uses different error messages that leak whether a username exists."
          type="vulnerable"
        >
          <form onSubmit={handleUnsafeSubmit}>
            <InputField
              label="Username"
              value={username}
              onChange={setUsername}
              placeholder="Try: admin, user, or a fake name"
              htmlFor="unsafe-username"
            />
            
            <InputField
              label="Password"
              type="password"
              value={password}
              onChange={setPassword}
              placeholder="Try: admin123 or anything else"
              htmlFor="unsafe-password"
            />
            
            <RunButton type="unsafe" onClick={(e) => e && handleUnsafeSubmit(e)} formButton>
              Login (Unsafe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={unsafeResult}
            type={unsafeResult?.includes("successful") ? "success" : "error"}
          />
          
          <SecurityMessage type="warning" title="Security Issue">
            Different error messages reveal whether a username exists,
            enabling account enumeration attacks.
          </SecurityMessage>

          <ExploitControls>
            <RunButton 
              type={isAttacking && attackMode === 'unsafe' ? 'secondary' : 'unsafe'}
              onClick={() => runUserEnumerationAttack('unsafe')}
              disabled={isAttacking && attackMode !== 'unsafe'}
            >
              {isAttacking && attackMode === 'unsafe' ? "Stop Attack" : "Run Username Enumeration Attack"}
            </RunButton>
          </ExploitControls>
        </ImplementationContainer>
        
        {/* Secure Implementation */}
        <ImplementationContainer
          title="Secure Implementation"
          description="This implementation uses the same generic error message regardless of the error type."
          type="secure"
        >
          <form onSubmit={handleSafeSubmit}>
            <InputField
              label="Username"
              value={username}
              onChange={setUsername}
              placeholder="Try: admin, user, or a fake name"
              htmlFor="safe-username"
            />
            
            <InputField
              label="Password"
              type="password"
              value={password}
              onChange={setPassword}
              placeholder="Try: admin123 or anything else"
              htmlFor="safe-password"
            />
            
            <RunButton type="safe" onClick={(e) => e && handleSafeSubmit(e)} formButton>
              Login (Safe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={safeResult}
            type={safeResult?.includes("successful") ? "success" : "error"}
          />
          
          <SecurityMessage type="success" title="Security Fix">
            Using the same generic error message prevents 
            username enumeration attacks.
          </SecurityMessage>

          <ExploitControls>
            <RunButton 
              type={isAttacking && attackMode === 'safe' ? 'secondary' : 'safe'}
              onClick={() => runUserEnumerationAttack('safe')}
              disabled={isAttacking && attackMode !== 'safe'}
            >
              {isAttacking && attackMode === 'safe' ? "Stop Attack" : "Run Username Enumeration Attack"}
            </RunButton>
          </ExploitControls>
        </ImplementationContainer>
      </div>
      
      {/* Attack results section with minimum height to prevent layout shift */}
      <div className="attack-results-wrapper">
        {showAttackResults && (
          <div className="exploit-attack">
            <h4>Username Enumeration Attack Results</h4>
            
            <div className="attack-results">
              {foundUsernames.length > 0 && (
                <div className="found-usernames">
                  <h5>Discovered Valid Usernames:</h5>
                  <div className="username-list">
                    {foundUsernames.map((username, i) => (
                      <div key={i} className="username-item">
                        <span className="username-badge">{username}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <AttackLog 
                logs={attackLog}
                isVisible={attackLog.length > 0}
                title="Attack Log"
              />
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default StorageSideChannel;