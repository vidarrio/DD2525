import React, { useState, useContext, useRef, useEffect } from 'react';
import { WasmErrorContext } from '../../../../App';
import * as wasm from 'wasm-security-test';
import CodeViewer from '../../../Utils/CodeViewer';
import { 
  ImplementationContainer, 
  InputField, 
  RunButton, 
  ResultDisplay, 
  SecurityMessage, 
  AttackControls, 
  AttackLog,
  OutputPanel
} from '../../../Shared';

// Define interface for charTimings used in the attack simulation
interface CharTiming {
  char: string;
  time: number;
  matches: number;
}

const TimingSideChannel: React.FC = () => {
  const [username, setUsername] = useState('admin');
  const [password, setPassword] = useState('');
  const [unsafeResult, setUnsafeResult] = useState('');
  const [safeResult, setSafeResult] = useState('');
  const [isAttacking, setIsAttacking] = useState(false);
  const [hasRunAttack, setHasRunAttack] = useState(false);
  const [attackMode, setAttackMode] = useState<'unsafe' | 'safe'>('unsafe');
  const [attackLog, setAttackLog] = useState<string[]>([]);
  const [timings, setTimings] = useState<{char: string, time: number}[]>([]);
  const { addError } = useContext(WasmErrorContext);
  
  const abortControllerRef = useRef<AbortController | null>(null);
  const logContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Auto-scroll the log container when content changes
  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [attackLog]);

  const handleUnsafeSubmit = (e?: React.FormEvent | React.MouseEvent) => {
    if (e) e.preventDefault();
    try {
      const result = wasm.unsafe_check_credentials_timing(username, password);
      
      setUnsafeResult(`${result.message} - Response time: ${result.simulated_time_ms.toFixed(2)}ms`);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const handleSafeSubmit = (e?: React.FormEvent | React.MouseEvent) => {
    if (e) e.preventDefault();
    try {
      const result = wasm.safe_check_credentials_timing(username, password);
      
      setSafeResult(`${result.message} - Response time: ${result.simulated_time_ms.toFixed(2)}ms`);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const displayTimings = React.useMemo(() => {
    // Keep array at fixed length of 10 to prevent layout shifts
    const result = Array(10).fill({ char: '', time: 0 });
    
    // Fill with actual timing data when available
    if (timings.length > 0) {
        timings.slice(0, 10).forEach((item, index) => {
        result[index] = item;
        });
    }
    
    return result;
  }, [timings]);

  const measurePasswordTiming = async (testPassword: string, useUnsafe: boolean): Promise<{ time: number }> => {
    try {
      const result = useUnsafe
        ? wasm.unsafe_check_credentials_timing('admin', testPassword)
        : wasm.safe_check_credentials_timing('admin', testPassword);
      
      return { 
        time: result.simulated_time_ms
      };
    } catch (error) {
      console.error("Error during timing measurement:", error);
      return { time: 0 };
    }
  };

  const runTimingAttack = async (mode: 'unsafe' | 'safe') => {
    if (isAttacking) {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setIsAttacking(false);
      return;
    }

    setIsAttacking(true);
    setHasRunAttack(true);
    setAttackMode(mode);
    setAttackLog([`Starting timing attack (${mode} implementation)...`]);
    setTimings([]);
    
    const controller = new AbortController();
    abortControllerRef.current = controller;
    const signal = controller.signal;

    try {
      // Only test relevant characters for the password (a-z, 0-9)
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let guessedPassword = '';
      const newLog: string[] = [];
      
      newLog.push(`Analyzing character-by-character timing differences for ${mode} implementation...`);
      
      if (mode === 'safe') {
        newLog.push("Note: The secure implementation should prevent timing analysis by using constant-time operations.");
      } else {
        newLog.push("Note: This demonstration uses simulated timing values to show the vulnerability clearly.");
      }
      
      setAttackLog(newLog);
      
      // Try to guess up to 8 characters
      for (let position = 0; position < 8; position++) {
        if (signal.aborted) break;
        
        newLog.push(`\nTesting characters for position ${position + 1}:`);
        setAttackLog([...newLog]);

        const charTimings: {char: string, time: number, matches: number}[] = [];
        
        // Test each possible character for this position
        for (let i = 0; i < chars.length; i++) {
          if (signal.aborted) break;
          
          const testChar = chars[i];
          const testPassword = guessedPassword + testChar;
          
          // Get timing information
          const { time } = await measurePasswordTiming(testPassword, mode === 'unsafe');
          
          // Infer matches from timing in unsafe mode
          const inferredMatches = mode === 'unsafe' ? 
            Math.round((time - 0.85) / 0.03) : // Based on the updated Rust implementation (0.85 base + 0.03ms per char)
            0;
          
          newLog.push(`Testing: ${testPassword} - ${inferredMatches} chars inferred (${time.toFixed(2)}ms)`);
          setAttackLog([...newLog]);
          
          charTimings.push({ char: testChar, time, matches: inferredMatches });
          
          // Update the visualization in real-time
          setTimings(charTimings
            .sort((a, b) => b.time - a.time)
            .map(item => ({
              char: item.char,
              time: item.time
            }))
          );
          
          // Small delay to keep the UI responsive
          await new Promise(r => setTimeout(r, 10));
        }
        
        if (signal.aborted) break;
        
        // Sort by timing (descending)
        charTimings.sort((a, b) => b.time - a.time);
        
        if (charTimings.length > 0) {
          const bestChar = charTimings[0].char;
          
          if (mode === 'unsafe') {
            // In the vulnerable version, the character with the longest timing is likely correct
            guessedPassword += bestChar;
            
            newLog.push(`Position ${position + 1}: Character with longest delay is "${bestChar}" (${charTimings[0].time.toFixed(2)}ms, ${charTimings[0].matches} chars inferred)`);
            newLog.push(`Password so far: ${guessedPassword}`);
            
            // Check if the correct password has been found
            if (guessedPassword === "admin123".substring(0, position + 1)) {
              newLog.push(`‚úÖ Correct character guessed!`);
            } else {
              newLog.push(`‚ùå Incorrect character guessed!`);
              break; // Stop on first error
            }
          } else {
            // In the secure version, timing should not reveal information
            newLog.push(`Position ${position + 1}: No conclusive timing pattern (constant-time comparison)`);
            
            // For demo purposes, just add a random character to show attack failed
            guessedPassword += bestChar;
            newLog.push(`Random guess: ${guessedPassword} (ineffective attack)`);
            
            // After a few attempts, conclude attack is unsuccessful
            if (position >= 2) {
              newLog.push(`\n‚úÖ Timing attack ineffective against constant-time implementation`);
              break;
            }
          }
        }
        
        setAttackLog([...newLog]);
      }
      
      // Final attack results
      if (!signal.aborted) {
        if (mode === 'unsafe' && guessedPassword.length > 0) {
          newLog.push(`\nüîç Attack complete! Extracted password prefix: ${guessedPassword}`);
        }
        
        setAttackLog([...newLog]);
      }
    } catch (error) {
      if (!signal.aborted) {
        setAttackLog([...attackLog, `Error during attack: ${error}`]);
      }
    } finally {
      if (!signal.aborted) {
        setIsAttacking(false);
        abortControllerRef.current = null;
      }
    }
  };

  // Determine if we should display the attack results section
  const showAttackResults = isAttacking || hasRunAttack;

  return (
    <div className={`exploit-container ${hasRunAttack ? 'attack-complete' : ''}`}>
      <h3>Timing Side-Channel Attack</h3>
      
      <div className="exploit-description">
        <p>
          This demonstration shows how processing time can leak information about secrets.
          In the vulnerable version, the password verification checks characters one by one
          and returns early on the first mismatch, creating measurable timing differences.
        </p>
        <p>
          <strong>Valid username:</strong> admin
          <br />
          <strong>Password:</strong> admin123
        </p>
        <p>
          <strong>Note:</strong> For demonstration purposes, this example uses simulated timing data to illustrate the vulnerability. In a real-world attack scenario, an adversary would measure these timing differences externally using specialized tools and network analysis. Since this React-based demo runs entirely in the browser without database queries or server communication, the actual timing variations are too small and inconsistent to reliably demonstrate the attack using JavaScript's built-in timing functions.
        </p>
        
        <CodeViewer 
          title="Timing Side-Channel Implementation"
          unsafeCode={`// UNSAFE VERSION: Leaks password length through timing
#[wasm_bindgen]
pub fn unsafe_check_credentials_timing(username: &str, password: &str) -> TimingResult {
    if username != "admin" {
        return TimingResult {
            message: "Error: Invalid username or password".to_string(),
            simulated_time_ms: 0.85, // Base processing time (milliseconds)
        };
    }
    
    let correct_password = "admin123";
    
    // Insecure character-by-character comparison
    let mut is_correct = true;
    let mut simulated_time: f64 = 0.85; // Base processing time (milliseconds)
    let min_length = std::cmp::min(password.len(), correct_password.len());
    
    for i in 0..min_length {
        // Check each character
        if password.chars().nth(i) != correct_password.chars().nth(i) {
            is_correct = false;
            break;
        }

        simulated_time += 0.03; // Add ~30 microseconds per character (shown as ms)
    }
    
    // If lengths are different, it's incorrect
    if password.len() != correct_password.len() {
        is_correct = false;
    }
    
    TimingResult {
        message: if is_correct {
            "Login successful".to_string()
        } else {
            "Error: Invalid username or password".to_string()
        },
        simulated_time_ms: simulated_time,
    }
}`}
          safeCode={`// SAFE VERSION: Constant-time comparison
#[wasm_bindgen]
pub fn safe_check_credentials_timing(username: &str, password: &str) -> TimingResult {
    if username != "admin" {
        return TimingResult {
            message: "Error: Invalid username or password".to_string(),
            simulated_time_ms: 1.05, // Constant processing time (milliseconds)
        };
    }
    
    let correct_password = "admin123";
    
    // Constant-time comparison - we always check all characters
    let mut result = if password.len() == correct_password.len() { 1 } else { 0 };
    
    // Compare all characters in constant time
    for i in 0..std::cmp::max(password.len(), correct_password.len()) {
        let pass_char = if i < password.len() { password.chars().nth(i).unwrap() as u32 } else { 0 };
        let correct_char = if i < correct_password.len() { correct_password.chars().nth(i).unwrap() as u32 } else { 0 };
        
        // Use bitwise AND to accumulate the result without branching
        result &= if pass_char == correct_char { 1 } else { 0 };
    }
    
    TimingResult {
        message: if result == 1 {
            "Login successful".to_string()
        } else {
            "Error: Invalid username or password".to_string()
        },
        simulated_time_ms: 1.05, // Always constant time (milliseconds)
    }
}`}
        />
      </div>
      
      <div className="exploit-implementations">
        {/* Vulnerable Implementation */}
        <ImplementationContainer
          type="vulnerable"
          title="Vulnerable Implementation"
          description="This implementation checks characters one by one and stops at the first mismatch."
        >
          <form onSubmit={handleUnsafeSubmit}>
            <InputField
              label="Username"
              value={username}
              onChange={setUsername}
              disabled={true}
              htmlFor="unsafe-timing-username"
            />
            
            <InputField
              label="Password"
              type="password"
              value={password}
              onChange={setPassword}
              placeholder="Try: a, ad, adm, etc."
              htmlFor="unsafe-timing-password"
            />
            
            <RunButton 
              type="unsafe" 
              onClick={handleUnsafeSubmit}
              formButton={true}
            >
              Login (Unsafe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={unsafeResult}
            type={unsafeResult.includes("successful") ? "success" : "error"}
          />
          
          <SecurityMessage type="warning" title="Security Issue">
            The character-by-character comparison with early exit creates timing differences 
            that leak information about how many characters were correct before a mismatch.
          </SecurityMessage>

          <AttackControls
            isAttacking={isAttacking}
            attackMode={attackMode}
            onStartAttack={(mode: 'unsafe' | 'safe') => runTimingAttack(mode)}
            onStopAttack={() => runTimingAttack(attackMode)}
            unsafeLabel="Run Timing Attack on Unsafe"
            safeLabel=""
          />
        </ImplementationContainer>
        
        {/* Secure Implementation */}
        <ImplementationContainer
          type="secure"
          title="Secure Implementation"
          description="This implementation uses constant-time comparison regardless of input."
        >
          <form onSubmit={handleSafeSubmit}>
            <InputField
              label="Username"
              value={username}
              onChange={setUsername}
              disabled={true}
              htmlFor="safe-timing-username"
            />
            
            <InputField
              label="Password"
              type="password"
              value={password}
              onChange={setPassword}
              placeholder="Try: a, ad, adm, etc."
              htmlFor="safe-timing-password"
            />
            
            <RunButton 
              type="safe" 
              onClick={handleSafeSubmit}
              formButton={true}
            >
              Login (Safe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={safeResult}
            type={safeResult.includes("successful") ? "success" : "error"}
          />
          
          <SecurityMessage type="success" title="Security Fix">
            Using constant-time comparison prevents timing differences, making it impossible 
            to determine how many characters matched.
          </SecurityMessage>

          <AttackControls
            isAttacking={isAttacking}
            attackMode={attackMode}
            onStartAttack={(mode: 'unsafe' | 'safe') => runTimingAttack(mode)}
            onStopAttack={() => runTimingAttack(attackMode)}
            unsafeLabel=""
            safeLabel="Run Timing Attack on Safe"
          />
        </ImplementationContainer>
      </div>
      
      {/* Attack results section with minimum height to prevent layout shift */}
      <div className="attack-results-wrapper">
        {showAttackResults && (
            <div className="exploit-attack">
                <h4>Password Timing Attack Results</h4>
                
                <div className="attack-results">
                <div className="timing-chart">
                    <h5>Character Timing Analysis:</h5>
                    <div className="chart-container">
                    {timings.length === 0 ? (
                        <div className="chart-placeholder">
                        No timing data available yet. Run the attack to see results.
                        </div>
                    ) : (
                        displayTimings.map((item, i) => (
                        <div key={i} className="chart-bar">
                            <div className="bar-label">{item.char || ' '}</div>
                            <div 
                            className="bar" 
                            style={{ 
                                width: item.time ? `${Math.min(100, (item.time / (timings[0]?.time || 1)) * 100)}%` : '0%',
                                backgroundColor: i === 0 && item.time > 0 ? '#ff6b6b' : '#4dabf7',
                                opacity: item.time ? 1 : 0.3,
                            }}
                            ></div>
                            <div className="bar-value">{item.time ? `${item.time.toFixed(1)}ms` : ''}</div>
                        </div>
                        ))
                    )}
                    </div>
                </div>
                
                <AttackLog 
                  logs={attackLog}
                  isVisible={attackLog.length > 0}
                  title="Attack Log"
                />
                </div>
            </div>
            )}
      </div>
    </div>
  );
};

export default TimingSideChannel;