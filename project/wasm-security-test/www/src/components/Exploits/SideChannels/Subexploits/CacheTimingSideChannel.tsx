import React, { useState, useContext, useRef, useEffect } from 'react';
import { WasmErrorContext } from '../../../../App';
import * as wasm from 'wasm-security-test';
import CodeViewer from '../../../Utils/CodeViewer';
import { 
  ImplementationContainer, 
  InputField, 
  RunButton, 
  ResultDisplay, 
  SecurityMessage, 
  AttackLog,
  AttackControls
} from '../../../Shared';

const CacheTimingSideChannel: React.FC = () => {
  // Add this constant for the hardcoded secret index
  const HARDCODED_SECRET_INDEX = 12;
  
  // These values match those in the Rust code
  const lookup_table_values = [
    0x7A, 0x2B, 0x15, 0xED, 0x9C, 0x5F, 0xD1, 0x41,
    0x86, 0x03, 0xB2, 0xA7, 0xE4, 0x6D, 0x33, 0xC8
  ];
  
  const [secretIndex, setSecretIndex] = useState<number>(5);
  const [unsafeResult, setUnsafeResult] = useState<string>('');
  const [safeResult, setSafeResult] = useState<string>('');
  const [isAttacking, setIsAttacking] = useState<boolean>(false);
  const [hasRunAttack, setHasRunAttack] = useState<boolean>(false);
  const [attackMode, setAttackMode] = useState<'unsafe' | 'safe'>('unsafe');
  const [attackLog, setAttackLog] = useState<string[]>([]);
  const [unsafeAccessPattern, setUnsafeAccessPattern] = useState<number[]>([]);
  const [safeAccessPattern, setSafeAccessPattern] = useState<number[]>([]);
  const [discoveredIndex, setDiscoveredIndex] = useState<number | null>(null);
  const [memoryValue, setMemoryValue] = useState<number | null>(null);
  
  const { addError } = useContext(WasmErrorContext);
  const abortControllerRef = useRef<AbortController | null>(null);

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const handleUnsafeSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const result = wasm.unsafe_cache_timing(secretIndex);
      setUnsafeResult(`${result.message} - Access time: ${result.simulated_time_ms.toFixed(2)}ms`);
      setUnsafeAccessPattern(Array.from(result.access_pattern));
      setMemoryValue(result.memory_value);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const handleSafeSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const result = wasm.safe_cache_timing(secretIndex);
      setSafeResult(`${result.message} - Access time: ${result.simulated_time_ms.toFixed(2)}ms`);
      setSafeAccessPattern(Array.from(result.access_pattern));
      setMemoryValue(result.memory_value);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runCacheTimingAttack = async (mode: 'unsafe' | 'safe') => {
    if (isAttacking) {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setIsAttacking(false);
      return;
    }

    setIsAttacking(true);
    setHasRunAttack(true);
    setAttackMode(mode);
    setAttackLog([`Starting cache timing attack (${mode} implementation)...`]);
    setDiscoveredIndex(null);
    
    const controller = new AbortController();
    abortControllerRef.current = controller;
    const signal = controller.signal;

    try {
      const newLog: string[] = [];
      
      newLog.push("Analyzing memory access timing patterns...");
      
      if (mode === 'safe') {
        newLog.push("Note: The secure implementation should access all memory locations regardless of the secret index.");
      } else {
        newLog.push("Note: The vulnerable implementation only accesses memory at the position determined by the secret index.");
      }
      
      setAttackLog(newLog);
      
      // Gather timing data for each possible index
      const timings: {index: number, time: number, value: number}[] = [];
      
      // Try indices 0-15
      for (let i = 0; i < 16; i++) {
        if (signal.aborted) break;
        
        newLog.push(`Testing index: ${i}`);
        setAttackLog([...newLog]);
        
        // Run multiple measurements to get more accurate timing
        let totalTime = 0;
        let memValue = 0;
        const iterations = 5;
        
        for (let j = 0; j < iterations; j++) {
          const result = mode === 'unsafe' 
            ? wasm.unsafe_cache_timing(i)
            : wasm.safe_cache_timing(i);
          
          totalTime += result.simulated_time_ms;
          memValue = result.memory_value;
          
          // Small delay to keep UI responsive
          await new Promise(r => setTimeout(r, 20));
        }
        
        const avgTime = totalTime / iterations;
        timings.push({ index: i, time: avgTime, value: memValue });
        
        newLog.push(`  Average timing for index ${i}: ${avgTime.toFixed(2)}ms`);
        newLog.push(`  Memory value: 0x${memValue.toString(16).toUpperCase().padStart(2, '0')}`);
        setAttackLog([...newLog]);
      }
      
      if (signal.aborted) return;
      
      if (mode === 'unsafe') {
        // For unsafe implementation, the lowest timing indicates the most likely secret index
        timings.sort((a, b) => a.time - b.time);
        const likelyIndex = timings[0].index;
        const secretValue = timings[0].value;
        
        newLog.push(`\nüîç Analysis complete!`);
        newLog.push(`Fastest access detected at index ${likelyIndex} (${timings[0].time.toFixed(2)}ms)`);
        newLog.push(`Memory value at this index: 0x${secretValue.toString(16).toUpperCase().padStart(2, '0')}`);
        newLog.push(`\nüîë FOUND SECRET KEY BYTE: 0x${secretValue.toString(16).toUpperCase().padStart(2, '0')}`);
        
        setDiscoveredIndex(likelyIndex);
      } else {
        // For safe implementation, timings should be nearly constant
        const maxDiff = Math.max(...timings.map(t => t.time)) - Math.min(...timings.map(t => t.time));
        
        newLog.push(`\nüîç Analysis complete!`);
        newLog.push(`All memory accesses had similar timing (max difference: ${maxDiff.toFixed(2)}ms)`);
        newLog.push(`Unable to determine which key byte is being used by the encryption algorithm.`);
      }
      
      setAttackLog([...newLog]);
      
    } catch (error) {
      if (!signal.aborted) {
        setAttackLog([...attackLog, `Error during attack: ${error}`]);
      }
    } finally {
      if (!signal.aborted) {
        setIsAttacking(false);
        abortControllerRef.current = null;
      }
    }
  };

  // Determine if we should display the attack results section
  const showAttackResults = isAttacking || hasRunAttack;

  return (
    <div className={`exploit-container ${hasRunAttack ? 'attack-complete' : ''}`}>
      <h3>Cache Timing Side-Channel Attack</h3>
      
      <div className="exploit-description">
        <p>
          This demonstration simulates a cache timing attack against an encryption algorithm. The vulnerable 
          implementation accesses a lookup table at an index determined by a secret key byte, which creates
          timing differences that can be observed by an attacker.
        </p>
        <p>
          <strong>Scenario:</strong> An encryption algorithm is using a secret key byte at index {HARDCODED_SECRET_INDEX} of a lookup table. This key byte (0xE4) is frequently accessed during encryption operations, causing that memory location to remain in the CPU cache. By measuring access times to different memory locations, an attacker can identify which location is cached and extract the secret key byte.
        </p>
        <p>
        <strong>Note:</strong> In real-world scenarios, these timing differences arise from CPU cache behavior, where cached memory access is significantly faster than uncached memory access. However, these microsecond-level variations cannot be measured accurately or consistently using JavaScript in a browser environment. For this demonstration, we use simulated timing values to clearly illustrate the timing attack concept.
      </p>
        
        <CodeViewer 
          title="Cache Timing Side-Channel Implementation"
          unsafeCode={`// Unsafe implementation - accesses memory in patterns that depend on secret data
#[wasm_bindgen]
pub fn unsafe_cache_timing(probe_index: u32) -> CacheTimingResult {
    // Create an array to simulate an AES lookup table in memory
    let buffer_size = 16;
    let mut lookup_table: Vec<u8> = vec![0; buffer_size];
    
    // Fill with realistic-looking encryption key bytes
    lookup_table[0] = 0x7A; 
    lookup_table[1] = 0x2B;
    lookup_table[2] = 0x15;
    lookup_table[3] = 0xED;
    lookup_table[4] = 0x9C;
    lookup_table[5] = 0x5F;
    lookup_table[6] = 0xD1;
    lookup_table[7] = 0x41;
    lookup_table[8] = 0x86;
    lookup_table[9] = 0x03;
    lookup_table[10] = 0xB2;
    lookup_table[11] = 0xA7;
    lookup_table[12] = 0xE4; // The "secret" key byte at index 12
    lookup_table[13] = 0x6D;
    lookup_table[14] = 0x33;
    lookup_table[15] = 0xC8;
    
    // Convert probe index to usize and ensure it's within bounds
    let index = (probe_index as usize) % buffer_size;
    
    // Access the table at the index being probed
    let accessed_value = lookup_table[index];
    
    // Hard-coded "secret" index for simulation
    const SECRET_INDEX: usize = 12;
    
    // Simulate timing - accessing the SECRET_INDEX is FASTER (cache hit)
    // while all other indices are slower (cache miss)
    let simulated_time = if index == SECRET_INDEX {
        0.02  // 20 nanoseconds for cache hit (shown as ms)
    } else {
        0.12 + (index as f64 * 0.005)  // ~120-200 nanoseconds for cache miss (shown as ms)
    };
    
    // Track which indices were accessed (for visualization)
    let mut access_pattern = vec![0; buffer_size];
    access_pattern[index] = 1;
    
    CacheTimingResult {
        message: format!("Accessed key byte: 0x{:02X}", accessed_value),
        simulated_time_ms: simulated_time,
        access_pattern,
        memory_value: accessed_value,
    }
}`}
          safeCode={`// Safe implementation - access pattern doesn't depend on secret data
#[wasm_bindgen]
pub fn safe_cache_timing(probe_index: u32) -> CacheTimingResult {
    let buffer_size = 16;
    let mut lookup_table: Vec<u8> = vec![0; buffer_size];
    
    // Lookup table filled with "encryption key" bytes
    lookup_table[0] = 0x7A;
    lookup_table[1] = 0x2B;
    lookup_table[2] = 0x15;
    lookup_table[3] = 0xED;
    lookup_table[4] = 0x9C;
    lookup_table[5] = 0x5F;
    lookup_table[6] = 0xD1;
    lookup_table[7] = 0x41;
    lookup_table[8] = 0x86;
    lookup_table[9] = 0x03;
    lookup_table[10] = 0xB2;
    lookup_table[11] = 0xA7;
    lookup_table[12] = 0xE4; // The "secret" key byte at index 12
    lookup_table[13] = 0x6D;
    lookup_table[14] = 0x33;
    lookup_table[15] = 0xC8;
    
    // Convert probe index to usize and ensure it's within bounds
    let index = (probe_index as usize) % buffer_size;
    
    // Always access EVERY element in the table regardless of the secret index
    let mut accessed_value = 0;
    let mut dummy_accumulator = 0u8;
    
    for i in 0..buffer_size {
        // Access every element to prevent optimization
        let value = lookup_table[i];
        if i == index {
            accessed_value = value;
        } else {
            // Use the value in a way that can't be optimized away
            // but doesn't affect the actual result
            dummy_accumulator = dummy_accumulator.wrapping_add(value);
        }
    }
    
    // Use the dummy_accumulator in a way that doesn't affect the result
    // but prevents the compiler from optimizing away the accesses
    if dummy_accumulator == 255 {
        accessed_value = accessed_value.wrapping_add(0);
    }
    
    // Track all memory accesses (for visualization)
    let access_pattern = vec![1; buffer_size];
    
    CacheTimingResult {
        message: format!("Accessed key byte: 0x{:02X}", accessed_value),
        simulated_time_ms: 0.25, // Constant time regardless of index (milliseconds)
        access_pattern,
        memory_value: accessed_value,
    }
}`}
        />
      </div>
      
      <div className="exploit-implementations">
        {/* Vulnerable Implementation */}
        <ImplementationContainer
          title="Vulnerable Implementation"
          description="This implementation accesses memory only at the location determined by the secret index."
          type="vulnerable"
        >
          <form onSubmit={handleUnsafeSubmit}>
            <InputField
              label="Secret Index (0-15)"
              type="number"
              value={secretIndex.toString()}
              onChange={(value) => setSecretIndex(parseInt(value) || 0)}
              htmlFor="unsafe-secret-index"
            />
            
            <RunButton type="unsafe" onClick={(e) => e && handleUnsafeSubmit(e)} formButton>
              Run (Unsafe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={unsafeResult}
            type="error"
          />
          
          {unsafeAccessPattern.length > 0 && (
            <div className="memory-pattern">
              <h5>Memory Access Pattern:</h5>
              <div className="pattern-visualization">
                {unsafeAccessPattern.map((accessed, i) => (
                  <div key={i} className={`memory-cell ${accessed ? 'accessed' : ''} ${i === HARDCODED_SECRET_INDEX ? 'secret' : ''}`}>
                    <span className="index">{i}</span>
                    <span className="value">0x{lookup_table_values[i].toString(16).toUpperCase().padStart(2, '0')}</span>
                  </div>
                ))}
              </div>
            </div>
          )}
          
          <SecurityMessage type="warning" title="Security Issue">
            The secret-dependent memory access pattern creates timing
            differences that can reveal the secret index.
          </SecurityMessage>

          <AttackControls
            isAttacking={isAttacking}
            attackMode={attackMode}
            onStartAttack={() => runCacheTimingAttack('unsafe')}
            onStopAttack={() => runCacheTimingAttack('unsafe')}
            disabled={isAttacking && attackMode !== 'unsafe'}
            unsafeLabel="Run Cache Timing Attack"
            safeLabel=""
          />
        </ImplementationContainer>
        
        {/* Secure Implementation */}
        <ImplementationContainer
          title="Secure Implementation"
          description="This implementation accesses all memory locations regardless of the secret index."
          type="secure"
        >
          <form onSubmit={handleSafeSubmit}>
            <InputField
              label="Secret Index (0-15)"
              type="number"
              value={secretIndex.toString()}
              onChange={(value) => setSecretIndex(parseInt(value) || 0)}
              htmlFor="safe-secret-index"
            />
            
            <RunButton type="safe" onClick={(e) => e && handleSafeSubmit(e)} formButton>
              Run (Safe)
            </RunButton>
          </form>
          
          <ResultDisplay 
            result={safeResult}
            type="success"
          />
          
          {safeAccessPattern.length > 0 && (
            <div className="memory-pattern">
              <h5>Memory Access Pattern:</h5>
              <div className="pattern-visualization">
                {safeAccessPattern.map((accessed, i) => (
                  <div key={i} className={`memory-cell ${accessed ? 'accessed' : ''} ${i === HARDCODED_SECRET_INDEX ? 'secret' : ''}`}>
                    <span className="index">{i}</span>
                    <span className="value">0x{lookup_table_values[i].toString(16).toUpperCase().padStart(2, '0')}</span>
                  </div>
                ))}
              </div>
            </div>
          )}
          
          <SecurityMessage type="success" title="Security Fix">
            By accessing all memory locations in the same pattern 
            regardless of the secret, there are no timing differences to exploit.
          </SecurityMessage>

          <AttackControls
            isAttacking={isAttacking}
            attackMode={attackMode}
            onStartAttack={() => runCacheTimingAttack('safe')}
            onStopAttack={() => runCacheTimingAttack('safe')}
            disabled={isAttacking && attackMode !== 'safe'}
            unsafeLabel=""
            safeLabel="Run Cache Timing Attack"
          />
        </ImplementationContainer>
      </div>
      
      {/* Attack results section */}
      <div className="attack-results-wrapper">
        {showAttackResults && (
          <div className="exploit-attack">
            <h4>Cache Timing Attack Results</h4>
            
            <div className="attack-results">
              {discoveredIndex !== null && (
                <div className="found-secret">
                  <h5>Discovered Secret Key Byte:</h5>
                  <div className="secret-display">
                    <span className="secret-badge">0x{lookup_table_values[discoveredIndex].toString(16).toUpperCase().padStart(2, '0')}</span>
                    <span className="secret-matches">
                      {discoveredIndex === HARDCODED_SECRET_INDEX
                        ? "(‚úì Successfully extracted the key byte!)" 
                        : "(‚úó Incorrect key byte identification)"}
                    </span>
                  </div>
                  <div className="secret-info">
                    <strong>Index:</strong> {discoveredIndex} &nbsp; | &nbsp; 
                    <strong>Expected:</strong> {HARDCODED_SECRET_INDEX}
                  </div>
                </div>
              )}
              
              <AttackLog 
                logs={attackLog}
                isVisible={attackLog.length > 0}
                title="Attack Log"
              />
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default CacheTimingSideChannel;