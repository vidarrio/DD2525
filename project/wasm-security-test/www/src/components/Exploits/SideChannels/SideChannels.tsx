import React, { useState, useContext } from 'react';
import StorageSideChannel from './Subexploits/StorageSideChannel';
import TimingSideChannel from './Subexploits/TimingSideChannel';
import CacheTimingSideChannel from './Subexploits/CacheTimingSideChannel';
import { WasmErrorContext } from '../../../App';
import '../../../styles/side-channels/index.css';

const SideChannels: React.FC = () => {
  const [activeTab, setActiveTab] = useState<string>('storage side channel');
  const { clearErrors } = useContext(WasmErrorContext);

  const changeTab = (tab: string) => {
    setActiveTab(tab);
    clearErrors(); // Clear errors when changing tabs
  };

  return (
    <div id="side-channels" className="page active">
      <h2>Side-Channel Attacks</h2>
      <p>
        Side-channel attacks extract sensitive information by observing the implementation
        of a system rather than attacking the algorithm directly. These demonstrations show
        how information can leak through unintended channels.
      </p>
      
      <div className="tabs">
        <button 
          className={`tab-btn ${activeTab === 'storage side channel' ? 'active' : ''}`}
          onClick={() => changeTab('storage side channel')}
        >
          Storage Side-Channel
        </button>
        <button 
          className={`tab-btn ${activeTab === 'timing side channel' ? 'active' : ''}`}
          onClick={() => changeTab('timing side channel')}
        >
          Timing Side-Channel
        </button>
        <button 
          className={`tab-btn ${activeTab === 'cache timing side channel' ? 'active' : ''}`}
          onClick={() => changeTab('cache timing side channel')}
        >
          Cache Timing Side-Channel
        </button>
      </div>
      
      {activeTab === 'storage side channel' && <StorageSideChannel />}
      {activeTab === 'timing side channel' && <TimingSideChannel />}
      {activeTab === 'cache timing side channel' && <CacheTimingSideChannel />}
    </div>
  );
};

export default SideChannels;