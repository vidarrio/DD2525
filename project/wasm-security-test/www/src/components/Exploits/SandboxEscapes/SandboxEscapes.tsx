import React, { useState, useContext } from 'react';
import DangerousHostExposure from './Subexploits/DangerousHostExposure';
import { WasmErrorContext } from '../../../App';
import '../../../styles/sandbox-escapes/index.css';

const SandboxEscapes: React.FC = () => {
  const [activeTab, setActiveTab] = useState<string>('dangerous host exposure');
  const { clearErrors } = useContext(WasmErrorContext);

  const changeTab = (tab: string) => {
    setActiveTab(tab);
    clearErrors(); // Clear errors when changing tabs
  };

  return (
    <div id="sandbox-escapes" className="page active">
      <h2>Sandbox Escape Vulnerabilities</h2>
      <p className="section-intro">
        WebAssembly's sandbox provides strong isolation for memory and execution, but it cannot 
        protect against poor decisions by the host environment. These demonstrations show how 
        improper host configuration can compromise the intended security boundaries.
      </p>
      
      <div className="tabs sandbox-escapes-tabs">
        <button 
          className={`tab-btn ${activeTab === 'dangerous host exposure' ? 'active' : ''}`}
          onClick={() => changeTab('dangerous host exposure')}
        >
          Dangerous Host Exposure
        </button>
      </div>
      
      <div className="sandbox-escapes-content">
        {activeTab === 'dangerous host exposure' && <DangerousHostExposure />}
      </div>
    </div>
  );
};

export default SandboxEscapes;
